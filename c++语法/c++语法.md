# 1.内存
## 1.1 c++语言的内存四区https://blog.csdn.net/qq_38769551/article/details/103099014  
类（未实例化），成员函数，函数，静态函数保存在代码区
## 1.2 操作系统的内存管理与c++。https://blog.csdn.net/quicmous/article/details/98755334
## 1.3 c++内存对齐https://zhuanlan.zhihu.com/p/30007037  
sizeof(struct)的计算
## 1.4 c++各数据类型的内存大小（一个字节8位）https://blog.csdn.net/zcyzsy/article/details/77935651
## 1.5 c++函数调用栈https://www.cnblogs.com/zuixime0515/p/13663796.html    
函数的栈为ebp（底） ~ esp（顶）这俩寄存器保存的地址之间。函数调用时，ebp入栈保存，然后esp内地址保存到。函数调用时参数入栈是从右往左，为了能够实现动态参数。
## 1.6 虚函数表https://zhuanlan.zhihu.com/p/75172640  
在编译阶段虚表就能编译出来。
## 1.7 malloc/free/new/delete  https://cloud.tencent.com/developer/article/1889881  
在遇到非内部数据类型（自定义）时，malloc和free是库函数，不是运算符，不在编译器控制权内，无法把他们改成能够自动调用析构构造函数，所以就有了new和delete这对运算符。  
malloc只关注申请空间大小，不会自动的通过数据类型来识别类型所需分配的空间，需要使用sizeof自己计算。
## 1.8 内存泄漏
# 2.面向对象   
## 2.1 多态：多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。  
静态多态：模板，函数重载 ：在编译阶段完成，编译器可以优化，效率高  
动态多态：虚函数 : 通过虚函数在运行期实现。处理同一继承体系下异质对象集合的强大威力。比如可以用来实现根据用户的输入动态调整调用的函数。
## 2.2 虚函数https://www.cnblogs.com/weiyouqing/p/7544988.html  
各个子类重写这些虚函数，以完成具体的功能。客户端的代码（操作函数）通过指向基类的引用或指针来操作这些对象，对虚函数的调用会自动绑定到实际提供的子类对象上去。  
它在运行时能够动态的识别指针指向的对象。   
1.含有虚函数的类实例化后会在最前面存在一个指向虚表的指针```_vfptr```（可能父类指针能够指向子类对象的原因就是这个同样拥有的虚表指针变量，只是内容不同）。每个类都会对应一个自己的虚表，虚表指针指向自己类对应的虚表。  
2.父类的指针，如果指向子类的对象，那么由于子类继承于父类，他也有虚表指针，所以可以访问到子类的虚表指针，通过子类的虚表指针去寻找子类的虚函数。  
## 2.3 继承  
1.在没有虚函数的情况下，调用哪个函数，取决于指针的类型。  
2.一般不会通过派生类指针指向父类，这样不安全，因为有一些只有派生类有的东西。  
## 2.4 this指针https://baike.baidu.com/item/C++this%E6%8C%87%E9%92%88/637012  
this作用在类内部，不影响sizeof对象大小。编译器会自动将对象本身的地址作为一个隐含参数传递给函数，非静态成员函数的隐含形参，对各成员的访问均通过this进行。
# 3.c++11新特性：  
## 3.1 智能指针https://blog.csdn.net/code_peak/article/details/119722167  
## 3.2 NULL和nullptr   
## 3.3 函数对象（仿函数） / 谓词https://blog.csdn.net/zhangyueweia/article/details/50440639?spm=1001.2101.3001.6650.1&depth_1-utm_relevant_index=2
# n.待分类  
## n.1 函数指针：只写函数名默认当做函数指针，函数指针解引用加括号然后再用括号写入参数就可以调用。  
