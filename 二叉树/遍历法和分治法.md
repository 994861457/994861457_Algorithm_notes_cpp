# 遍历法与分治法的区别  
遍历法：一个小人拿着记事本走遍所有节点。
分治法：分配小弟去做子任务，自己进行结果汇总。
# 一、分治法  
## 1.模板  
```cpp
  返回结果类型 divideCoquer(TreeNode root){
    if (!root){
      处理空树应该返回的结果
    }
    
    // if (root -> left == NULL && root -> right == NULL){
    //    处理叶子叶子应该返回的结果
    //    如果叶子的返回结果可以通过两个空节点的返回结果得到
    //    就可以省略这一段代码
    //}
    
    左子树返回结果 = divideConquer(root -> left)
    右子树返回结果 = divideConquer(root -> right)
    整棵树的结果 = 按照一定方法合并左右子树的结果  
    return 整棵树的结果
  
  }  
```
# 二、遍历法  
## 例：二叉树的所有路径 LintCode:480  
使用递归思想，不断将遇到的节点记录。并且采用了回溯思想，当记录完左节点以后，需要回溯到父节点，然后重新记录右节点，采用这种思路，就可以只用一个vector去保存路径上的节点，因为会回溯。  
```cpp  
  class Solution {
  public:
      vector<string> binaryTreePaths(TreeNode * root) {
          if (!root) return {};       
          vector<TreeNode *> nodes;
          vector<string> treePaths;
          nodes.push_back(root);
          findPaths(root, nodes, treePaths);
          return treePaths;
      }
  private:
      void findPaths(TreeNode * node, vector<TreeNode *> & nodes, vector<string> & treePaths){
          if (!node) return;          //遇到空节点，什么都不用做
          if (node -> left == NULL && node -> right == NULL){     //如果是叶子节点，那么打印一下收集到的路径，并且保存到treePath中。
              string path = to_string(nodes[0] -> val);           //并且后续的代码因为左右子树都为空而没有实际效果，只是把空节点入栈出栈一下。
              for (int i = 1; i < nodes.size(); i++){
                  path = path + "->" + to_string(nodes[i] -> val);
              }
              treePaths.push_back(path);
          }
          nodes.push_back(node -> left);                  //将左节点入栈
          findPaths(node -> left, nodes, treePaths);      //计算左子树，如果是左节点为空，就直接返回。
          nodes.pop_back();                               //将左节点出栈，因为接下来要记录右节点，需要在路径里面返回到跟节点，再添加右节点。
          nodes.push_back(node -> right);                 //已下与右子树思路相同。
          findPaths(node -> right, nodes, treePaths);
          nodes.pop_back();
      }
  };  
  ```  
  
