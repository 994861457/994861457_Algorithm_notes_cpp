# 一、二叉树  
## 1.遍历  
### 1.1 前序遍历   
前序遍历和层序遍历的差别就是把栈换成了队列，然后入栈时要注意先右后左。
```cpp
vector<int> preorderTraversal(TreeNode* root) {
        if (!root) return {};
        vector<int> results;
        stack<TreeNode*> stk;
        stk.push(root);
        while (!stk.empty()) {
            TreeNode* curr = stk.top();
            stk.pop();
            results.push_back(curr -> val);
            if (curr -> right) stk.push(curr -> right);
            if (curr -> left) stk.push(curr -> left);
        }
        return results;
    }  
```
### 1.2 中序遍历  LintCode:67
递归：  
```cpp  
        class Solution {
        public:
            vector<int> inorderTraversal(TreeNode* root) {
                 vector<int> results;
                recursion(root, results);
                return results;
            }
        private:
            void recursion(TreeNode* root, vector<int> &results){
                if (!root) return;
                recursion(root -> left, results);       //前中后序遍历就是改变这三句话的顺序
                results.push_back(root -> val);
                recursion(root -> right, results);
            }
        };  
```
非递归：首先按左子树遍历到空为止入栈，然后依次出栈，出栈时若含有右子树，则不断向左遍历到空为止，将它们入栈。直到所有元素出栈，栈空。
```cpp  
  vector<int> inorderTraversal(TreeNode* root) {
        vector<int> results;
        stack<TreeNode*> stk;
        while (root || !stk.empty()) {
            while (root) {
                stk.push(root);
                root = root -> left;
            }
            TreeNode* curr = stk.top(); //这里出栈后不能用root保存，因为这样的话，会造成无限重复入栈左节点，只有当出栈以后有右节点才更新root为右节点。
            results.push_back(curr -> val); //输出value只靠这句话。
            stk.pop();
            if (curr -> right){
                root = curr -> right;
            }
        }
        return results;
    }
```  
### 1.3 后序遍历  
先按根右左遍历，也就是前序遍历换左右。然后结果倒着排就是  
```cpp  
        vector<int> postorderTraversal(TreeNode* root) {
                if (!root) return {};
                vector<int> results;
                stack<TreeNode*> stk;
                stk.push(root);
                while (!stk.empty()) {
                    TreeNode* curr = stk.top();
                    stk.pop();
                    results.push_back(curr -> val);
                    if (curr -> left) stk.push(curr -> left);
                    if (curr -> right) stk.push(curr -> right);
                }
                reverse(results.begin(), results.end());
                return results;
            }  
```
## 2. 根据前序遍历和中序遍历重建二叉树  LeetCode:105  
前序遍历的第一个节点为根节点，通过根节点去寻找中序遍历中的根，中序遍历的根前面是左子树，后面是右子树。根据中序遍历得知左子树长度，确定前序遍历的左子树区间。确定两个数组的左右子树区间即可递归。通过哈希表保存中序遍历的位置加快查找速度。  
[3,9,20,15,7]  区间 1-1 2-4   
[9,3,15,20,7]  区间 0-0 2-4  
```cpp  
  class Solution {
  public:
      TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
               unordered_map<int, int> hash;
              for (int i = 0; i < pre.size(); i++){
                  hash.insert({vin[i], i});
              }
              return buildBT(pre, vin, 0, pre.size() - 1, 0, pre.size() - 1, hash);
      }
      private:
      TreeNode* buildBT(vector<int> &preorder, vector<int> &inorder, int leftStart, int leftEnd,int rightStart, int rightEnd, unordered_map<int,int> hash){
          if (leftStart > leftEnd) return nullptr;
          TreeNode* curr = new TreeNode(preorder[leftStart]);
          int rootIndex = hash[preorder[leftStart]];
          int leftLength = rootIndex - rightStart;
  //         int rightLength = end - hash[preorder[start]];
          curr -> left = buildBT(preorder, inorder, leftStart + 1, leftStart + leftLength, rightStart, rootIndex - 1, hash);
          curr -> right = buildBT(preorder, inorder, leftStart + leftLength + 1, leftEnd, rootIndex + 1, rightEnd, hash);
          return curr;
      }
  };  
```  
## 3. 中序遍历后序遍历，通过后序遍历的末尾是根节点然后去中序遍历找左右子树区间，然后再回来确定后序遍历左右子树区间。
# 二、二叉搜索（查找）树  
## 1.二叉树删除  一般删除操作都是遍历的时候以想要接上去的点作为返回值，相当于遍历的时候重新确立左右子树关系。
删除节点： Leetcode:450  
```cpp  
  class Solution {
  public:
      TreeNode* deleteNode(TreeNode* root, int key) {
        if (!root) return nullptr;
        if (root -> val > key) root -> left = deleteNode(root -> left, key);
        else if (root -> val < key) root -> right = deleteNode(root -> right, key);
        else{
            if (root -> left == nullptr) return root -> right;
            if (root -> right == nullptr) return root -> left;
            TreeNode* final_left = root -> right;
            while (final_left -> left != nullptr){
                  final_left = final_left -> left;
            }   
            final_left -> left = root -> left;
            return root -> right;
        }     
        return root;
      }
  };
  ```  
  按照范围修剪二叉搜索树 LintCode：701  
  ```cpp  
  class Solution {
  public:
      TreeNode * trimBST(TreeNode * root, int minimum, int maximum) {
          // write your code here
          if (!root) return nullptr;
          root -> left = trimBST(root -> left, minimum, maximum);
          root -> right = trimBST(root -> right, minimum, maximum);
          if (root -> val < minimum) return root -> right;
          if (root -> val > maximum) return root -> left;

          return root;
      }
  };  
  ```  
## 2.二叉搜索树与双向链表    
不能新建节点
使用迭代型的中序遍历，然后使用pre保存前一个节点，然后遍历相连。
```cpp  
        TreeNode* Convert(TreeNode* pRootOfTree) {
                if (!pRootOfTree) return pRootOfTree;
                TreeNode* root = pRootOfTree;
                TreeNode* pre = nullptr;
                stack<TreeNode*> stk;
                while (root){
                    stk.push(root);
                    root = root -> left;
                }
                TreeNode* head = stk.top();
                while (!stk.empty()) {
                    TreeNode* curr = stk.top();
                    curr -> left = pre;
                    if (pre) pre -> right = curr;
                    pre = curr;
                    stk.pop();
                    root = curr -> right;
                    while (root){
                         stk.push(root);
                         root = root -> left;
                    }
                }
                return head;
            }  
```
# 三、红黑树
# 四、判断是不是完全二叉树 BM35  
```cpp
        class Solution {
        public:
            bool isCompleteTree(TreeNode* root) {
                if (!root) return true;
                queue<TreeNode*> que;
                que.push(root);
                bool flag = false;
                bool flag2 = false;
                while (!que.empty() && !flag){
                    int size = que.size();
                    for (int i = 0; i < size; i++){
                        TreeNode* curr = que.front();
                        que.pop();
                        if (!(curr -> left)) flag = true; 
                        que.push(curr -> left);
                        if (!(curr -> right)) flag = true; 
                        que.push(curr -> right);
                    }
                }
                while (!que.empty()){
                    TreeNode* curr = que.front();
                    que.pop();
                    if (curr){
                        if (flag2) return false;
                        if (curr -> left) return false;
                        if (curr -> right) return false;
                    }
                    else {
                        flag2 = true;
                    }
                }
                return true;
            }
        };
```
