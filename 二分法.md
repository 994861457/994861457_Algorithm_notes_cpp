
# 二分法   
## 核心思想:将区间一分为二，通过某种方法去确定在哪个区间，然后反复二分的缩小区间。
## 1.递归  
步骤：  
1.递归的定义  
2.递归的拆解  
3.终止条件  
缺点：耗费栈空间 
### 例：斐波那契数列 
```cpp 
    int fibonacci(int n) {
       if (n <= 2){
           return n - 1;
       }
       return fibonacci(n - 1) + fibonacci(n - 2);
    } 
```     
超时（重复计算了很多数，每一层不关心之前算好的层，所以要重算）使用循环改进如下： 
```cpp 
    int fibonacci(int n) {
        if (n <= 2){
            return n - 1;
        }
        int temp1 = 0;
        int temp2 = 1;
        int temp = 0;
        for (int i = 0; i < n - 2; i++){
            temp = temp2;
            temp2 = temp1 + temp2;
            temp1 = temp;
       }
        return temp2;
    }
```
## 2.用递归实现二分法（思想简单，但比较耗费栈空间<font color = red>不推荐</font> ）  
### 例：二分查找一个数，相同取任意位置均可  LintCode:457
```cpp 
    int findPosition(vector<int> &nums, int target) {
        // write your code here
        return binarySearch(nums, target, 0, nums.size()-1);
    }

    int binarySearch(vector<int> &nums, int target, int start, int end){
        int mid = start + (end - start) / 2;
        if (start > end){
            return -1;
        }
        if (target == nums[mid]){
            return mid;
        }
        if (target < nums[mid]){
            return binarySearch(nums, target, start, mid - 1);
        }
        if (target > nums[mid]){
            return binarySearch(nums, target, mid + 1, end);
        }
    }
```
## 3.用循环实现二分法<font color = red>（通用模板推荐！！！）</font>    LintCode:458/14/457 
```cpp
    int lastPosition(vector<int> &nums, int target) {
        if (nums.empty()){
            return -1;//排除空数组
        }

        int start = 0;
        int end = nums.size() - 1;

        while (start + 1 < end){//加一可以避免不能退出循环的bug
            int mid = start + (end - start) / 2;
            if (nums[mid] < target){
                start = mid;    
            }
            else if (nums[mid] == target){
                start = mid;//寻找边界情况下找到值后需要继续寻找
                //end = mid;
            }
            else{
                end = mid;
            }
        }
        //左侧边界右侧边界调整先后顺序
        if (nums[end] == target){
            return end;
        }
        if (nums[start] == target){
            return start;
        }
        return -1;
    }
```  
# 二分法扩展  
## 4.在大数组中查找 LintCode：447
通过倍增法不断倍增最右边界，扩大查找范围，直到边界大于目标值，然后使用二分查找  
```cpp
     int searchBigSortedArray(ArrayReader * reader, int target) {
        int rangeTotal = 1;
        while (reader->get(rangeTotal) < target){
            rangeTotal = rangeTotal * 2;
        }

        int start = 0, end = rangeTotal;
        while (start + 1 < end){
            int mid = start + (end - start) / 2;
            if (reader->get(mid) < target){
                start = mid;
            }
            else {
                end = mid;
            }
        }

        if (reader->get(start) == target) return start;
        if (reader->get(end) ==target) return end;
        return -1;
    }  
```  

## 5.山脉序列中最大值（严格单调递增递减） LintCode：585  
按照中间值和下一个值之间的变化趋势，判断应该选择哪边的区间。  
```cpp  
    int mountainSequence(vector<int> &nums) {
        if (nums.empty()) return -1;
        int start = 0;
        int end = nums.size() - 1;
        while (start + 1 < end){
            int mid = start + (end - start) / 2;
            if (nums[mid] < nums[mid + 1]) start = mid;
            else end = mid;
        }
        if(nums[start] > nums[end]) return nums[start];
        return nums[end];
    }  
```  
## 6.旋转排序数组搜索数的位置 LintCode：62
首先判断mid是在旋转数组的前半段还是旋转数组的后半段，再判断目标值在mid的哪一边，以及在旋转数组的哪一段，是一个四分类讨论。
```cpp  
    int search(vector<int> &A, int target) {
        if (A.empty()) return -1;
        int start = 0;
        int end = A.size() - 1;
        while (start + 1 < end){
            int mid = start + (end - start) / 2;
            if (A[mid] > A[end]){
                if (target <= A[mid] && target >= A[start]) end = mid;
                else start = mid;
            }
            else {
                if (target >= A[mid] && target <= A[end]) start = mid;
                else end =mid;
            }
        }

        if (A[start] == target) return start;
        if (A[end] == target) return end;
        return -1;
    }  
```  
## 7.旋转排序数最小值（非递增） BM21  
```cpp 
    class Solution {
    public:
        int minNumberInRotateArray(vector<int> rotateArray) {
            int start = 0;
            int end = rotateArray.size() - 1;
            while (start + 1 < end){
                int mid = start + (end - start) / 2;
                if (rotateArray[mid] > rotateArray[end]) {          //这里要以end为基准，不能以start，考虑到只有一个数字不相等的情况
                    start = mid;
                }
                else if (rotateArray[mid] < rotateArray[end]) {
                    end = mid;
                }
                else{
                    end = end - 1;              //相等就只能一个一个来，出现相等情况只可能是大面积相等，就一个不同。
                }
            }
            if (rotateArray[start] < rotateArray[end]) return rotateArray[start];
            else return rotateArray[end];
        }
    };
```
# 应用题  
## 木材加工 LintCode:183  
有一些原木，现在想把这些木头切割成一些长度相同的小段木头，需要得到的小段的数目至少为 k。给定L和k，你需要计算能够得到的小段木头的最大长度。  
思路：通过给定的小段数目k，直接求最大长度很难。通过长度来算能切的数目比较简单。是一个递减的函数关系，通过二分法逐渐缩小长度的范围，从而获取满足条件的最大长度。
```cpp  
    class Solution {
    public:
        int woodCut(vector<int> &L, int k) {    
            if (L.empty()) return 0;
            int start = 1;
            int end = * max_element(L.begin(), L.end());    //确定最大范围，假设段数为1，那么只要找最长的木头就行
            while (start + 1 < end){
                int mid = start + (end - start) / 2;
                if (CalCounts(L, mid) >= k) start = mid;    //如果满足至少为k的条件就继续往右找，试图找更长
                else end = mid;
            }

            if (CalCounts(L, end) >= k) return end;    //先判断end，因为end比start大，如果end先满足条件就选他
            if (CalCounts(L, start) >= k) return start;
            return 0;
        }
    private:
        int CalCounts(vector<int> &L, int woodLen){     //通过长度计算段数的函数
            int counts = 0;
            for (int i = 0; i < L.size();i++){
                counts += L[i] / woodLen;
            }
            return counts;
        }
    }    
```  




    

