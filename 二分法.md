
# 二分法  
## 1.递归  
步骤：  
1.递归的定义  
2.递归的拆解  
3.终止条件  
缺点：耗费栈空间 
### 例：斐波那契数列 
```cpp 
    int fibonacci(int n) {
       if (n <= 2){
           return n - 1;
       }
       return fibonacci(n - 1) + fibonacci(n - 2);
    } 
```     
超时（重复计算了很多数，每一层不关心之前算好的层，所以要重算）使用循环改进如下： 
```cpp 
    int fibonacci(int n) {
        if (n <= 2){
            return n - 1;
        }
        int temp1 = 0;
        int temp2 = 1;
        int temp = 0;
        for (int i = 0; i < n - 2; i++){
            temp = temp2;
            temp2 = temp1 + temp2;
            temp1 = temp;
       }
        return temp2;
    }
```
## 2.用递归实现二分法（思想简单，但比较耗费栈空间<font color = red>不推荐</font> ）  
### 例：二分查找一个数，相同取任意位置均可  LintCode:457
```cpp 
    int findPosition(vector<int> &nums, int target) {
        // write your code here
        return binarySearch(nums, target, 0, nums.size()-1);
    }

    int binarySearch(vector<int> &nums, int target, int start, int end){
        int mid = start + (end - start) / 2;
        if (start > end){
            return -1;
        }
        if (target == nums[mid]){
            return mid;
        }
        if (target < nums[mid]){
            return binarySearch(nums, target, start, mid - 1);
        }
        if (target > nums[mid]){
            return binarySearch(nums, target, mid + 1, end);
        }
    }
```
## 3.用循环实现二分法<font color = red>（通用模板推荐！！！）</font>    LintCode:458/14/457 
```cpp
    int lastPosition(vector<int> &nums, int target) {
        if (nums.empty()){
            return -1;//排除空数组
        }

        int start = 0;
        int end = nums.size() - 1;

        while (start + 1 < end){//加一可以避免不能退出循环的bug
            int mid = start + (end - start) / 2;
            if (nums[mid] < target){
                start = mid;    
            }
            else if (nums[mid] == target){
                start = mid;//寻找边界情况下找到值后需要继续寻找
                //end = mid;
            }
            else{
                end = mid;
            }
        }
        //左侧边界右侧边界调整先后顺序
        if (nums[end] == target){
            return end;
        }
        if (nums[start] == target){
            return start;
        }
        return -1;
    }
```  
# 二分法扩展  
## 4.在大数组中查找 LintCode：447
通过倍增法不断倍增最右边界，扩大查找范围，直到边界大于目标值，然后使用二分查找  
```cpp
     int searchBigSortedArray(ArrayReader * reader, int target) {
        int rangeTotal = 1;
        while (reader->get(rangeTotal) < target){
            rangeTotal = rangeTotal * 2;
        }

        int start = 0, end = rangeTotal;
        while (start + 1 < end){
            int mid = start + (end - start) / 2;
            if (reader->get(mid) < target){
                start = mid;
            }
            else {
                end = mid;
            }
        }

        if (reader->get(start) == target) return start;
        if (reader->get(end) ==target) return end;
        return -1;
    }  
```  
## 5. 寻找最接近的K个数 LintCode:460  
先找到最右边的小于目标值的位置。然后通过归并排序的思想分别从左边和右边按差值从小到大选取最接近的数。
```cpp  
    class Solution {
public:
    vector<int> kClosestNumbers(vector<int> &A, int target, int k) {
       vector<int> v;
       int left = findLowerClosest(A, target);  //使用二分法寻找小于目标的最右边的数的位置
       int right = left + 1;
       for (int i = 0; i < k; i++){
           if(left < 0) v.push_back(A[right++]); //如果左边已经到头了，接下来都选择右边的数
           else if (right >  A.size() - 1) v.push_back(A[left--]);//如果右边已经到头了，接下来都选择左边的数
           else if (target - A[left] <= A[right] - target ){
               v.push_back(A[left--]);
           }
            else if (target - A[left] > A[right] - target){
               v.push_back(A[right++]);
           }
       }
       return v;
    }

private:
    int findLowerClosest(vector<int> &A, int target){
        int left = 0;
        int right = A.size() - 1;
        while (left + 1 < right){
            int mid = left + (right - left) / 2;
            if (A[mid] < target) left = mid;
            else right = mid;
        } 
        if (A[right] < target) return right;    //找最右边的所以先比较右边
        if (A[left] < target) return  left;
        return -1;   //找不到说明所有的数都大于等于targert
    }
};
 
```  
## 6.山脉序列中最大值（严格单调递增递减） LintCode：585  
按照中间值和下一个值之间的变化趋势，判断应该选择哪边的区间。  
```cpp  
    int mountainSequence(vector<int> &nums) {
        if (nums.empty()) return -1;
        int start = 0;
        int end = nums.size() - 1;
        while (start + 1 < end){
            int mid = start + (end - start) / 2;
            if (nums[mid] < nums[mid + 1]) start = mid;
            else end = mid;
        }
        if(nums[start] > nums[end]) return nums[start];
        return nums[end];
    }  
```



    

