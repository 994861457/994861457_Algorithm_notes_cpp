<!-- TOC -->

- [服务器项目](#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE)
    - [各部分实现的整体流程  https://blog.csdn.net/qq_36459662/article/details/106564574](#%E5%90%84%E9%83%A8%E5%88%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B--httpsblogcsdnnetqq_36459662articledetails106564574)
        - [线程池](#%E7%BA%BF%E7%A8%8B%E6%B1%A0)
        - [线程同步机制封装类](#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%B0%81%E8%A3%85%E7%B1%BB)
        - [proactor与reactor](#proactor%E4%B8%8Ereactor)
        - [http_conn请求类](#http_conn%E8%AF%B7%E6%B1%82%E7%B1%BB)
            - [解析报文](#%E8%A7%A3%E6%9E%90%E6%8A%A5%E6%96%87)
            - [做出响应](#%E5%81%9A%E5%87%BA%E5%93%8D%E5%BA%94)
        - [mysql服务器](#mysql%E6%9C%8D%E5%8A%A1%E5%99%A8)
        - [定时器](#%E5%AE%9A%E6%97%B6%E5%99%A8)
        - [同步异步日志系统](#%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F)
    - [服务器框架](#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6)
    - [线程池](#%E7%BA%BF%E7%A8%8B%E6%B1%A0)
    - [日志是怎么实现的](#%E6%97%A5%E5%BF%97%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84)
    - [日志中用到的单例模式](#%E6%97%A5%E5%BF%97%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)
    - [信号统一事件源](#%E4%BF%A1%E5%8F%B7%E7%BB%9F%E4%B8%80%E4%BA%8B%E4%BB%B6%E6%BA%90)
    - [setsockopt函数](#setsockopt%E5%87%BD%E6%95%B0)
    - [惊群效应](#%E6%83%8A%E7%BE%A4%E6%95%88%E5%BA%94)
    - [ET和LT](#et%E5%92%8Clt)
    - [条件变量](#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F)
    - [accept，poll和epoll优缺点和应用场景](#acceptpoll%E5%92%8Cepoll%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)
- [c++语法](#c%E8%AF%AD%E6%B3%95)
    - [为什么构造函数里面不能调用虚函数](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0)
    - [函数调用栈原理](#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E5%8E%9F%E7%90%86)
    - [模板特化](#%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96)
    - [如何调试代码bug](#%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81bug)
    - [move函数和左值右值](#move%E5%87%BD%E6%95%B0%E5%92%8C%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC)
    - [static的作用](#static%E7%9A%84%E4%BD%9C%E7%94%A8)
    - [函数值传递的方式](#%E5%87%BD%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E6%96%B9%E5%BC%8F)
    - [类有哪些默认的函数](#%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E9%BB%98%E8%AE%A4%E7%9A%84%E5%87%BD%E6%95%B0)
- [stl](#stl)
    - [容器的底层原理](#%E5%AE%B9%E5%99%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86)
- [计算机网络](#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C)
    - [socket通信流程](#socket%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B)
    - [DNS具体流程](#dns%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B)
    - [七层网络模型](#%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B)
    - [粘包问题，包头里面的成员](#%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E5%8C%85%E5%A4%B4%E9%87%8C%E9%9D%A2%E7%9A%84%E6%88%90%E5%91%98)
    - [linux下默认可以使用最大的端口数目](#linux%E4%B8%8B%E9%BB%98%E8%AE%A4%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%9C%80%E5%A4%A7%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%95%B0%E7%9B%AE)
    - [http请求流程](#http%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B)
- [操作系统](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)
    - [协程](#%E5%8D%8F%E7%A8%8B)
    - [进程和线程的区别](#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB)
    - [怎么查看cpu占用率](#%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8Bcpu%E5%8D%A0%E7%94%A8%E7%8E%87)
    - [大端小端](#%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF)
    - [进程间通信管道，共享内存，消息队列等以及各自的应用场景](#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%AE%A1%E9%81%93%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AD%89%E4%BB%A5%E5%8F%8A%E5%90%84%E8%87%AA%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF)
- [算法](#%E7%AE%97%E6%B3%95)
    - [排序算法](#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)
    - [说一说红黑树](#%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%BA%A2%E9%BB%91%E6%A0%91)
- [设计模式了解哪些](#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B)

<!-- /TOC -->
# 服务器项目  
## 0.各部分实现的整体流程  https://blog.csdn.net/qq_36459662/article/details/106564574
### 1.线程池  
线程池是一种用空间换时间的策略，事先把线程创建好，放入池子内，当有任务在任务队列中时（链表保存），空闲的线程会被激活去取一个任务执行。操作队列的时候要加锁。一次请求对应一个线程处理而不是一个客户端对应一个线程。也就是创建的线程会一直从队列中抢任务，任务执行完继续抢。
### 2.线程同步机制封装类  
信号量、互斥量、条件变量使用时需要init，用完需要destroy。可以使用RAII技术将这些同步机制的生命周期与类的对象绑定，可以实现用构造自动初始化，用析构自动销毁。
### 3.proactor与reactor  
reactor：主线程只负责监听文件描述符上是否有事件发生，有的话就将事件通知工作线程。除此之外，主线程不做任何其他实质性的工作。
同步IO模拟proactor：linux异步I/O并不成熟。主线程负责监听文件描述符上是否有事件发生并且执行数据读写操作，读写完成后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。
### 4.http_conn请求类 
#### 1.解析报文 
任务类的执行内容：从状态机负责读取报文的一行，主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。主状态机根据状态分别解析请求行，请求头部和消息体，从状态机记录读取一行的情况并把末尾从\r\n改为\0\0，读取到了完整的行才会交给主状态机去解析。
主状态机：三种状态，标识解析位置
●CHECK_STATE_REQUESTLINE，解析请求行
●CHECK_STATE_HEADER，解析请求头部
●CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求

从状态机：三种状态，标识解析一行的读取状态。
●LINE_OK，完整读取一行
●LINE_BAD，报文语法有误
●LINE_OPEN，读取的行不完整

解析请求中的HTTP_CODE含义，表示HTTP请求的处理结果，在头文件中初始化了八种情形，在报文解析时只涉及到四种。
●NO_REQUEST
 请求不完整，需要继续读取请求报文数据

●GET_REQUEST
 获得了完整的HTTP请求

●BAD_REQUEST
 HTTP请求报文有语法错误

●INTERNAL_ERROR
 服务器内部错误，该结果在主状态机逻辑switch的default下，一般不会触发
#### 2. 做出响应  
根据解析请求处理结果HTTP_CODE的状态，调用do_request()。根据解析出的m_url得到对应的html文件，将其映射到内存中。根据解析情况产生响应行响应头然后利用writev函数与响应体连接在一起写到缓冲区，然后通知主线程，主线程写，或者reactor模式通知子线程写。  
### 5. mysql服务器  
数据库类使用单例模式和RAII技术。数据库需要主线程初始化时创建连接池，线程在拿到任务的初期就会去连接池取一个MySQL句柄放到任务对象的成员变量中保存。所以连接池是由处理任务的线程去取连接的。mysql连接池队列里保存的是MYSQL句柄。
### 6. 定时器  
服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时，有一个定时器类记录了文件描述符和ip以及定时的绝对时间：当前时间+规定的超时时间。利用升序时间链表容器将所有定时器串联起来,信号处理函数利用管道通知主循环，主循环接收到该信号后调用tick()处理当前时间到期的所有定时器，如果到期，调用该定时器的cb_func函数删除资源.如果一个任务被读写找到对应的定时器然后增加超时时间。
定时器其他方案设计：升序链表（时间轮），堆（时间堆）
### 7. 同步异步日志系统  
阻塞队列里面放的是待写的文本，队列里放的是string
异步会创建一个额外的线程，总共就一个，去阻塞队列（阻塞队列类中封装了生产者-消费者模型）上取文本写。线程与任务处理线程是并发，互不干扰
同步直接通过函数写入文本。 
日志分级：
●Debug，调试代码时的输出，在系统实际运行时，一般不使用。
●Warn，这种警告与调试时终端的warning类似，同样是调试代码时使用。
●Info，报告系统当前的状态，当前执行的流程或接收的信息等。

●Error和Fatal，输出系统的错误信息。  
超过行数、按天分文件逻辑：
●日志写入前会判断当前day是否为创建日志的时间，行数是否超过最大行限制
 若为创建日志时间，写入日志，否则按当前时间创建新log，更新创建时间和行数
 若行数超过最大行限制，在当前日志的末尾加count/max_lines为后缀创建新log
## 1.服务器框架  
## 2.线程池

## 4.日志是怎么实现的  
## 5.日志中用到的单例模式  
## 6.信号统一事件源  
如果有信号被捕获，系统就会终端进程去执行信号处理函数，这时会屏蔽其他信号。信号统一事件源就是说把信号处理函数要执行的内容变为处理函数通过管道向主线程传递信号，将这个事件加入epoll中统一处理。像定时器到时关闭连接不是非常紧急的任务，可以等到处理完一次epoll送来的所有事件以后再去处理该任务。这样屏蔽其他信号的时间就大大缩短了。
## 7.setsockopt函数   
里面能设置端口复用
## 8.惊群效应   
就是扔一块食物，所有鸽子（线程/进程）来抢，但最终只一个鸽子抢到了食物。所有鸽子都来抢浪费资源。
比如一个io事件被触发以后会同时激活多个线程中的epoll  
本项目中的线程池解决了这一个问题，只有主线程去通过epoll监听io事件，多线程只负责处理读取到的数据。
## 8.ET和LT 
非阻塞ET模式下，需要一次性将数据读完，EAGAIN即缓冲区无数据可读(读完)
## 9.条件变量
## 10.accept，poll和epoll优缺点和应用场景
# c++语法
## 1.为什么构造函数里面不能调用虚函数  
如果在基类中调用虚函数，那么如果你实例化一个派生类会先调用基类的构造函数，这时派生类的东西还没有初始化，那就不知道你是去调用基类虚函数还是派生类的虚函数，或者是哪个虚函数也不知道。如果调用派生类的，那么虚函数中可能存在一些派生类的成员变量还没被初始化，结果是灾难性的。   
## 2. 函数调用栈原理  
栈空间向下生长， 栈帧保存了函数调用所需要的所有信息。函数的返回地址临时变量和上下文，函数的状态信息。跟栈有关的有两个比较重要的寄存器，一个是rbp64位/ebp32位是基址指针寄存器，和rsp栈指针寄存器。分别记录函数栈底，以及当前栈顶。  
1.当函数发生调用的时候。保存上下文信息。会将入参保存到寄存器eax中（不够可能就会分配其他栈空间），然后入栈rbp（这就是（栈底的）返回地址），把rsp的内容写到rbp，此时栈底就更新为被调函数的栈底了，然后函数参数从寄存器入栈，之后就是被调函数有些局部变量入栈，执行一些运算。返回值的结果保存在寄存器中eax。  
2.返回。将rbp的值传给rsp先更新栈顶（因为要找到上一个函数栈底必须先将这个函数的栈底找到，返回地址就保存在附近，但不能直接获得，所以先更新rsp），然后返回地址出栈更新ebp为返回地址。然后恢复上下文信息。然后就可以将寄存器中的返回值入栈了。
## 3. 模板特化       
## 4. 如何调试代码bug  
## 5. move函数和左值右值 
## 6. static的作用
## 7. 函数值传递的方式
## 8.类有哪些默认的函数
# stl  
## 1.容器的底层原理
# 计算机网络  
## 1.socket通信流程
## 2.DNS具体流程
## 3.七层网络模型  
1.物理层： 利用传输介质，为数据链路层提供物理连接，尽可能屏蔽掉传输介质和物理设备的差异（协议，比如考虑电平，速度等等），让数据链路层不用考虑具体的介质是什么。通过物理介质传输比特流，也就是比特流是一样的，但是需要物理层通过电平规定，速度规定等来实现物理介质传输它们，不同物理介质它们的电平等的规定不同。网线
2.数据链路层：主要解决同一网络内节点之间的通信。 物理链路不可靠，通过差错控制，流量控制使有差错的物理链路变成可靠的数据链路。 将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。
MAC地址：物理地址用于在网络中唯一标示一个网卡。数据包在节点之间的传递都是由 ARP（Address Resolution Protocol：地址解析协议）负责将IP地址映射到 MAC地址上来完成的。 3.网络层：主要解决不同网络间的通信。 定义IP编址，定义路由功能。通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。数据在这一层被转换为数据包
局域网通信不包含网络层，因为他不需要网络间的通信，只需要实现网络内节点间的通信。广域网需要网络层。
IP地址：为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。
4.传输层：端到端传输数据的基本功能，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。TCP,UDP协议。段 5.会话层：控制应用程序之间会话能力，组织和协调两个会话进程之间的通信，并对数据交换进行管理。
6.表示层：将计算机内部的多种数据格式转换成通信中采用的标准表示形式，确保能被另一个应用层识别。
7.应用层：它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。
## 4.粘包问题，包头里面的成员
## 5.linux下默认可以使用最大的端口数目
## 6.http请求流程  
域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户。
# 操作系统  
## 1.协程 
## 2.进程和线程的区别  
## 3.怎么查看cpu占用率  
## 4.大端小端
## 5.进程间通信(管道，共享内存，消息队列等)以及各自的应用场景

# 算法  
## 1.排序算法  
## 2.说一说红黑树 
# 设计模式了解哪些
