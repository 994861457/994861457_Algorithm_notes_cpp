# 16.逆波兰表达式求值   
如果遇到数就入栈，如果遇到符号，先取出两个数然后运算，得到的结果再入栈。
```cpp
  int evalRPN(vector<string>& tokens) {
        stack<string> stk;
        unordered_set<string> hash = {"+", "-", "*", "/"};
        for (auto token : tokens){
            if (!hash.count(token)){
                stk.push(token);
            }
            else{
                int b = stoi(stk.top());
                stk.pop();
                int a = stoi(stk.top());
                stk.pop();
                switch(token[0]){      
                    case '+':
                        stk.push(to_string(a + b));
                        break;
                    case '-':
                        stk.push(to_string(a - b));
                        break;
                    case '*':
                        stk.push(to_string(a * b));
                        break;
                    case '/':
                        stk.push(to_string(a / b));
                }
            }
        }
        return stoi(stk.top());
    }
```
# 26.字符串解码   
思路和表达式求值一样，遇到左括号和字母一样入栈，遇到右括号就弹出字母直到弹出左括号为止，然后处理括号之间的字母，处理完以后还得重新入栈。此外需要另外一个栈来保存数字。
```cpp
   string decodeString(string s) {
          stack<int> amount;
          int tempN = 0;
          stack<char> ch;
          string result;

          for (auto l : s){
              if (l >= '0' && l <= '9'){
                  tempN = tempN * 10 + (l - '0');
              }
              else if (l == ']'){
                  string add;
                  int num;
                  string temp;
                  while(ch.top() != '['){

                      temp.push_back(ch.top());
                      ch.pop();
                  }
                  ch.pop();
                  reverse(temp.begin(), temp.end());
                  num = amount.top();
                  amount.pop();
                  for (int i = 0; i < num; i++){
                      add += temp;
                  }    
                  for (auto a : add){
                      ch.push(a);
                  }
              }
              else{
                  if (l == '['){
                      amount.push(tempN);
                      tempN = 0;
                  }
                  ch.push(l);
              }
          }
      while (!ch.empty()){
          result.push_back(ch.top());
          ch.pop();
      }
      reverse(result.begin(), result.end());
      return result;
      }
```
