# 1.逆波兰表达式求值   
如果遇到数就入栈，如果遇到符号，先取出两个数然后运算，得到的结果再入栈。
```cpp
  int evalRPN(vector<string>& tokens) {
        stack<string> stk;
        unordered_set<string> hash = {"+", "-", "*", "/"};
        for (auto token : tokens){
            if (!hash.count(token)){
                stk.push(token);
            }
            else{
                int b = stoi(stk.top());
                stk.pop();
                int a = stoi(stk.top());
                stk.pop();
                switch(token[0]){      
                    case '+':
                        stk.push(to_string(a + b));
                        break;
                    case '-':
                        stk.push(to_string(a - b));
                        break;
                    case '*':
                        stk.push(to_string(a * b));
                        break;
                    case '/':
                        stk.push(to_string(a / b));
                }
            }
        }
        return stoi(stk.top());
    }
```
# 2.字符串解码   
思路和表达式求值一样，遇到左括号和字母一样入栈，遇到右括号就弹出字母直到弹出左括号为止，然后处理括号之间的字母，处理完以后还得重新入栈。此外需要另外一个栈来保存数字。
```cpp
   string decodeString(string s) {
          stack<int> amount;
          int tempN = 0;
          stack<char> ch;
          string result;

          for (auto l : s){
              if (l >= '0' && l <= '9'){
                  tempN = tempN * 10 + (l - '0');
              }
              else if (l == ']'){
                  string add;
                  int num;
                  string temp;
                  while(ch.top() != '['){

                      temp.push_back(ch.top());
                      ch.pop();
                  }
                  ch.pop();
                  reverse(temp.begin(), temp.end());
                  num = amount.top();
                  amount.pop();
                  for (int i = 0; i < num; i++){
                      add += temp;
                  }    
                  for (auto a : add){
                      ch.push(a);
                  }
              }
              else{
                  if (l == '['){
                      amount.push(tempN);
                      tempN = 0;
                  }
                  ch.push(l);
              }
          }
      while (!ch.empty()){
          result.push_back(ch.top());
          ch.pop();
      }
      reverse(result.begin(), result.end());
      return result;
      }
```
# 4.文本左右对齐 LeetCode:68   
```cpp
   vector<string> fullJustify(vector<string>& words, int maxWidth) {
          int leftIndex = 0, rightIndex = 0;
          vector<string> results;
          while (true){
              int sumSize = 0; //首先需要判断一行能够塞进去几个单词。要先判断能不能塞进去再塞进去算总长度。不然停下来的时候是已经把那个值塞进去了，还需要减掉，并且把指针往回移动比较麻烦。
              while(rightIndex < words.size() && sumSize + words[rightIndex].size() + rightIndex - leftIndex <= maxWidth){
                  sumSize += words[rightIndex++].size();
              }
              string result;
              if (rightIndex == words.size()){     //遇到指针到底了，就说明是最后一行，最后一行需要间隔一个空格左对齐，剩余补空格。
                  while (leftIndex + 1 < rightIndex){
                      result += words[leftIndex++] + " ";
                  }
                  result += words[leftIndex++];
                  result += string(maxWidth - result.size(), ' ');
                  results.push_back(result);
                  break;
              }
              if (rightIndex - leftIndex ==  1){  //遇到只能插入一个，也是左对齐补空格
                  result += words[leftIndex++];
                  result += string(maxWidth - result.size(), ' ');
                  results.push_back(result);
                  continue;
              }
              int blankSize = maxWidth - sumSize;   //普通情况需要插入连续空格的次数为总共能塞入的词量减一。
              int everySize = blankSize / (rightIndex - leftIndex - 1); //所以总的空格数除以总共能塞入的词量减一。
              int left = blankSize % (rightIndex - leftIndex - 1);//余数是多出来的，从左边开始每次插入空格时都取一个放入，这样来尽量保存平衡。
              while (leftIndex + 1 < rightIndex){       //最后一个数需要额外考虑，因为后面不用插入空格，所以判断条件要+1。
                  result += words[leftIndex++];
                  result += string(everySize, ' ');
                  if (left != 0){
                      result += " ";
                      left--;
                  } 
              }
              result += words[leftIndex++];
              results.push_back(result);
          }
          return results;
      }
```
# 5.生命游戏 LeetCode:289    
由于矩阵是int型的，这道题可以使用二进制法来保存更新前和更新后的信息。第一位保存更新后的状态，第二位为原来状态。  
二进制判断某一位状态的方法，用1左移几位相与，这样就可以只提取要找的那一位。
二进制更新某一位状态的方法，想要更新0就与0（其他为均1），想要更新1就或1（其他位均0）.
```cpp
   class Solution {
  public:
     void gameOfLife(vector<vector<int>>& board) {

          //特殊情况的判断
          if (board.empty() || board[0].empty()) return;

          //方便计算相邻格子的坐标
          vector<int> deltaX = {0, -1, 0, 1, -1, 1, -1, 1};
          vector<int> deltaY = {1, 0, -1, 0, -1, -1, 1, 1};

          //逐个遍历每一个格子
          for (int i = 0; i < board.size(); i++) {
              for (int j = 0; j < board[0].size(); j++) {

                  //用来记录周围活细胞的个数
                  int count = 0;

                  //循环遍历周围的八个点记录活细胞的数量
                  for (int num = 0; num < 8; num++) {
                          int nextX = i + deltaX[num];
                          int nextY = j + deltaY[num];
                          if (nextX >= 0 && nextX < board.size() && nextY >= 0 && nextY < board[0].size()) {

                              //使用与运算只取最后一位判断，因为第一位是更新的状态信息，第二位是原来的状态信息。
                              if ((board[nextX][nextY] & 1) == 1) count++;
                          }
                  }

                  //如果中心细胞原来的状态存活
                  if ((board[i][j] & 1) == 1) {
                      if (count == 2 || count == 3) {
                          board[i][j] |= (1 << 1);
                      }

                  //如果中心细胞原来状态死亡
                  } else {

                      if (count == 3){
                          board[i][j] |= (1 << 1);
                      }
                  }
              }
          }
          //移除原来的状态信息，仅保留现在的状态信息
          for (int i = 0; i < board.size(); i++) {
              for (int j = 0; j < board[0].size(); j++) {
                  board[i][j] = (board[i][j] >> 1);
              }
          }
      }
  };
```
# 6. 对角线遍历矩阵 LeetCode:498  
```cpp
  class Solution {
  public:
     vector<int> findDiagonalOrder(vector<vector<int>>& mat) {
          //考虑特殊情况
          if (mat.empty() || mat[0].empty()) return {};  

          //提前保存矩阵的行数和列数
          int m = mat.size();
          int n = mat[0].size();

          //初始化坐标以及保存答案的数组
          int i = 0;
          int j = 0;
          vector<int> result;

          //找到对角线遍历的重复规律就是一次斜向上一次斜向下
          while (true) {

              //斜向上遍历
              while (i >= 0 && j < n) {
                  result.push_back(mat[i--][j++]);

                  //保存完右下角的点那就可以退出了
                  if (i + 1 == m - 1 && j - 1 == n - 1) return result;
              }
              i++;
              j--;

              //如果碰到上边界就往右移一格，如果右边界就往下移一格。
              if (j + 1 < n) j++;
              else i++;

              //斜向下遍历
              while (i < m && j >= 0) {
                  result.push_back(mat[i++][j--]);

                  //保存完右下角的点那就可以退出了
                  if (i - 1 == m - 1 && j + 1 == n - 1) return result;
              }
              i--;
              j++;

              //如果碰到左边界就向下，碰到下边界就向右
              if (i + 1 < m) i++;
              else j++; 
          }
      }
  };
```
