# 宽度优先搜索   
## BFS使用场景    
---
一.连通块问题  1.通过一个点找到图中连通的所有点  2.非递归方式找所有方案  
二.分层遍历    1.图的层次遍历                  2.简单图的最短路径  
三.拓扑排序    1.求任意拓扑排序 2.求是否有拓扑排序 3.求字典序最小的拓扑序 4.求是否唯一拓扑序  
---
## 1.二叉树的层次遍历 LintCode:69  
利用队列先进先出的特性，来保存子节点。
```cpp  
  class Solution {
  public:
      vector<vector<int>> levelOrder(TreeNode * root) {
         if(!root) return {};
         vector<vector<int>> results; 
         queue<TreeNode *> nodeQue;
         nodeQue.push(root);
         while (!nodeQue.empty()){
             int que_size = nodeQue.size();   //因为不是单纯的只要遍历，而是要按层输出，所以要记录层的节点数
             vector<int> result;
             for (int i = 0; i < que_size; i++){    //需要遍历完一层，输出，如果不用按层输出，就不用特地按层节点数循环完
                 TreeNode * ptr = nodeQue.front();
                 result.push_back(ptr -> val);
                 nodeQue.pop();
                 if (ptr -> left) nodeQue.push(ptr -> left);
                 if (ptr -> right) nodeQue.push(ptr -> right);
             }
             results.push_back(result);      
         } 
         return results;
      }
  };
  ```  
  ## 2.克隆图  
  先遍历一遍节点并保存,第二步拷贝节点,利用哈希表建立拷贝的点与原来节点的连接.最后利用哈希表拷贝图的边  
  ```cpp  
 class Solution {
  public:
      UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
          if (!node) return nullptr;
          auto nodes = findNodesByBFS(node);
          auto mapping = copyNodes(nodes);
          copyEdges(nodes, mapping);
          return mapping[node];
      }
  private:
  /*************************************宽度优先搜索模板(排除重复遍历)*******************************************/
      vector<UndirectedGraphNode*> findNodesByBFS(UndirectedGraphNode* node){  //使用宽度优先搜索遍历节点并保存节点
          queue<UndirectedGraphNode*> que;
          vector<UndirectedGraphNode*> nodes;
          unordered_set <UndirectedGraphNode*> visited;
          que.push(node);
          visited.insert(node);
          while (!que.empty()){
              auto currNode = que.front();
              que.pop();
                        
              nodes.push_back(currNode);                                        
              //visited.insert(currNode);                                       这里标记时机错误,应该一入队就要标记,不然重复元素就会入队
              for (auto neighbor : currNode -> neighbors) {
                if (visited.find(neighbor) != visited.end()) continue;           //如果遇到哈希表中已经存在的节点就跳过
                visited.insert(neighbor);
                que.push(neighbor);                                         //所以要加在这里
              }
          } 
          return nodes;      
      }
   /*************************************************模板*****************************************************/
       unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> copyNodes(auto &nodes){    //拷贝节点的函数,使用哈希表保存并与原节点建立联系.
          unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> mapping;
          for (auto node : nodes) mapping.insert({node,new UndirectedGraphNode(node -> label)});
          return mapping;
      }
       void copyEdges(auto &nodes, auto &mapping){                                          //拷贝边的函数
          for (auto node : nodes){
              for (auto neighbor : node -> neighbors) (mapping[node] -> neighbors).push_back(mapping[neighbor]);
          }
      }
  };  
```
  
