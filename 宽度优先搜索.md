# 宽度优先搜索   
## BFS使用场景    
---
一.连通块问题  1.通过一个点找到图中连通的所有点  2.非递归方式找所有方案  
二.分层遍历    1.图的层次遍历                  2.简单图的最短路径  
三.拓扑排序    1.求任意拓扑排序 2.求是否有拓扑排序 3.求字典序最小的拓扑序 4.求是否唯一拓扑序  
---
## 1.二叉树的层次遍历 LintCode:69  
利用队列先进先出的特性，来保存子节点。
```cpp  
  class Solution {
  public:
      vector<vector<int>> levelOrder(TreeNode * root) {
         if(!root) return {};
         vector<vector<int>> results; 
         queue<TreeNode *> nodeQue;
         nodeQue.push(root);
         while (!nodeQue.empty()){
             int que_size = nodeQue.size();   //因为不是单纯的只要遍历，而是要按层输出，所以要记录层的节点数
             vector<int> result;
             for (int i = 0; i < que_size; i++){    //需要遍历完一层，输出，如果不用按层输出，就不用特地按层节点数循环完
                 TreeNode * ptr = nodeQue.front();
                 result.push_back(ptr -> val);
                 nodeQue.pop();
                 if (ptr -> left) nodeQue.push(ptr -> left);
                 if (ptr -> right) nodeQue.push(ptr -> right);
             }
             results.push_back(result);      
         } 
         return results;
      }
  };
  ```  
  ## 2.克隆图  
  先遍历一遍节点并保存,第二步拷贝节点,利用哈希表建立拷贝的点与原来节点的连接.最后利用哈希表拷贝图的边  
  ```cpp  
 class Solution {
  public:
      UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {
          if (!node) return nullptr;
          auto nodes = findNodesByBFS(node);
          auto mapping = copyNodes(nodes);
          copyEdges(nodes, mapping);
          return mapping[node];
      }
  private:
  /*************************************宽度优先搜索模板(排除重复遍历)*******************************************/
      vector<UndirectedGraphNode*> findNodesByBFS(UndirectedGraphNode* node){  //使用宽度优先搜索遍历节点并保存节点
          queue<UndirectedGraphNode*> que;
          vector<UndirectedGraphNode*> nodes;
          unordered_set <UndirectedGraphNode*> visited;
          que.push(node);
          visited.insert(node);
          while (!que.empty()){
              auto currNode = que.front();
              que.pop();
                        
              nodes.push_back(currNode);                                        
              //visited.insert(currNode);                                       这里标记时机错误,应该一入队就要标记,不然重复元素就会入队
              for (auto neighbor : currNode -> neighbors) {
                if (visited.find(neighbor) != visited.end()) continue;           //如果遇到哈希表中已经存在的节点就跳过
                visited.insert(neighbor);
                que.push(neighbor);                                         //所以要加在这里
              }
          } 
          return nodes;      
      }
   /*************************************************模板*****************************************************/
       unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> copyNodes(auto &nodes){    //拷贝节点的函数,使用哈希表保存并与原节点建立联系.
          unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> mapping;
          for (auto node : nodes) mapping.insert({node,new UndirectedGraphNode(node -> label)});
          return mapping;
      }
       void copyEdges(auto &nodes, auto &mapping){                                          //拷贝边的函数
          for (auto node : nodes){
              for (auto neighbor : node -> neighbors) (mapping[node] -> neighbors).push_back(mapping[neighbor]);
          }
      }
  };  
```  
## 3.岛屿问题(个数)  
在矩阵中扫描值为1的点,当找到1个后对其使用宽度优先搜索,一层一层的向四周寻找点,如果同样为1,就标记为已访问,表示属于同一个岛屿,这些点不用额外去计数.使用二维数组保存已访问情况.
```cpp  
class Solution {
public:
    int numIslands(vector<vector<bool>> &grid) {
        if (grid.empty()) return 0;
        int n = grid.size();
        int m = grid[0].size();
        int counts = 0;
       
        vector<vector<bool>> visited(n,vector<bool>(m,false));
        for (int i = 0; i < n; i++){
            for (int j = 0; j < m; j++){
                if(grid[i][j] && (!visited[i][j])){
                    bfs(grid, i, j, visited);
                    counts++;
                }
            }
        }

        return counts;
    }

    void bfs(auto &grid, int i, int j,auto &visited){
        queue<pair<int,int>> que;
        que.push(pair<int,int>(i, j));
        visited[i][j] = true;
        vector<int> deltaX = {-1, 0, 1, 0};
        vector<int> deltaY = {0, -1, 0, 1};
        while (!que.empty()){
            auto curr = que.front();
            que.pop();
            for (int n = 0; n < 4; n++){
                int nextX = curr.first + deltaX[n];
                int nextY = curr.second + deltaY[n];
                if (isValid(grid, visited, nextX, nextY)){
                    que.push(pair<int, int>(nextX, nextY));
                    visited[nextX][nextY] = true;
                }
            }
        }
    }

    bool isValid(auto &grid,auto &visited, int x, int y){
        int n = grid.size();
        int m = grid[0].size();
        if (x >= 0 && x < n && y >= 0 && y < m){
            if (visited[x][y]) return false;
            return grid[x][y];
        }
        return false;
    }
};
```
  
