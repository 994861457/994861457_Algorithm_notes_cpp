# 深度优先搜索  
## 递归三要素   
定义: 函数的输入输出,函数的作用  
拆解: 将问题拆分,然后通过调用自己逐渐整合小问题答案,然后解决大问题  
出口: 拆解成小问题到最小的时候,就可以直接解决了,能有退出递归的时候,不能让他一直递归下去导致栈溢出.  
## 使用场合  
所有可能方案一般使用深度优先搜索，如果题目没有直接给你树，或者图，那就把题目的解空间看成树或者图。找到图或树中所有满足条件的解决方案。  
路径 = 方案 = 所有路径的排列组合
## 组合类DFS    
时间复杂度  = 方案个数（2^n）*每个方案时间复杂度 (n) = 2^n × n    
例 子集 LintCode：17  
方法一
![](https://github.com/994861457/994861457_Algorithm_notes_cpp/blob/main/%E5%9B%BE%E7%89%87/QQ%E5%9B%BE%E7%89%8720220130163738.jpg)  
```cpp  
  class Solution {
  public:
      /**
       * @param nums: A set of numbers
       * @return: A list of lists
       */
      vector<vector<int>> subsets(vector<int> &nums) {

          if (nums.empty()) return{{}};
          sort(nums.begin(), nums.end());
          vector<vector<int>> results;
          vector<int> subset;
          dfs(nums, 0, subset, results);
          return results;
      }

  private:
      void dfs(auto nums, int startIndex, auto &subset, auto &results){
          results.push_back(subset);
          for (int i = startIndex; i < nums.size(); i++){                           //每深入一层都会跳过已经访问过的元素，向后移一个数
              //if (i != 0 && nums[i] == nums[i - 1] && i > startIndex) continue;  //带重复元素的子集的题加上这句就是答案  //当发现是第二个相同元素时，如果set里面未出现过相同的数就舍弃。也就是说如果发现该数不是重复数中的第一个，那就需要看看他的兄弟节点，如果他是兄弟节点中最左边那个就说明添加是有效的。
              subset.push_back(nums[i]);
              dfs(nums, i + 1, subset, results);
              subset.pop_back();
          }

      }

  };  
  ```
  方法二：按照加不加某数来生成二叉树。  
  ## 排列类DFS  
  ```cpp  
  class Solution {
  public:
      vector<vector<int>> permute(vector<int> &nums) {
          sort(nums.begin(), nums.end());
          vector<int> permutation;
          vector<vector<int>> permutations;
          unordered_set<int> visited;
          dfs(nums, visited, permutation, permutations);
          return permutations;
      }

  private:
      void dfs(auto &nums,auto &visited, auto &permutation, auto &permutations){
          if (nums.size() == visited.size()) {
              permutations.push_back(permutation);
              return;
          }
          for (int i = 0; i < nums.size(); i++){
              if (visited.find(nums[i]) != visited.end()) continue;
              if (i != 0 && nums[i] == nums[i - 1] && (visited.find(nums[i - 1]) == visited.end())) continue; //当前数和前面数一样，但前面数以前没出现过。
              permutation.push_back(nums[i]);
              visited.insert(nums[i]);
              dfs(nums, visited,permutation, permutations);
              permutation.pop_back();
              visited.erase(nums[i]);
          }
      }
  };
```


