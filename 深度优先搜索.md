# 深度优先搜索  
## 使用场合  
所有可能方案一般使用深度优先搜索
## 组合类DFS  
例 子集 LintCode：17  
方法一
![](https://github.com/994861457/994861457_Algorithm_notes_cpp/blob/main/%E5%9B%BE%E7%89%87/QQ%E5%9B%BE%E7%89%8720220130163738.jpg)  
```cpp  
  class Solution {
  public:
      /**
       * @param nums: A set of numbers
       * @return: A list of lists
       */
      vector<vector<int>> subsets(vector<int> &nums) {

          if (nums.empty()) return{{}};
          sort(nums.begin(), nums.end());
          vector<vector<int>> results;
          vector<int> subset;
          dfs(nums, 0, subset, results);
          return results;
      }

  private:
      void dfs(auto nums, int startIndex, auto &subset, auto &results){
          results.push_back(subset);
          for (int i = startIndex; i < nums.size(); i++){                           //每深入一层都会跳过已经访问过的元素，向后移一个数
              //if (i != 0 && nums[i] == nums[i - 1] && i > startIndex) continue;  //带重复元素的子集的题加上这句就是答案  //当发现是第二个相同元素时，如果set里面未出现过相同的数就舍弃。也就是说如果发现该数不是重复数中的第一个，那就需要看看他的兄弟节点，如果他是兄弟节点中最左边那个就说明添加是有效的。
              subset.push_back(nums[i]);
              dfs(nums, i + 1, subset, results);
              subset.pop_back();
          }

      }

  };  
  ```
  方法二：按照加不加某数来生成二叉树。



