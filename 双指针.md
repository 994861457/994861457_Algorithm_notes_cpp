# 双指针  
（拿到数组先想想排个序有没有用，拿到子串问题想想能不能用双指针）
## 1.相向双指针  
#### 例:有效回文串 LintCode:415  
双指针相向移动，遇到无效字符就跳过（使用while循环确保跳过连续无效字符），中途只要遇到字符不相等就return false ，如果循环结束都没有return 就说明是回文子串。  
isalnum:判断字符是否为字母或者数字    
tolower：将字符串全变成小写
```cpp  
   bool isPalindrome(string &s) {
        if (s.empty()) return true;
        int left = 0;
        int right =s.size() - 1;
        while (left < right){
           while (!isalnum(s[left])) left++;
            while (!isalnum(s[right])) right--;
            if (left < right && tolower(s[left++]) != tolower(s[right--])) return false;
            // if (left < right){
            //         left++;
            //         right--;
            // }
        }
        return true;
    }
```
### 1.1 Reverse型  
### 1.2 Two Sum型
### 1.3 Partition型
## 2.背向双指针   
### 2.1 回文串问题  
### 2.2 找最近的k个数 （从一个值开始依次从左右用两个指针进行向外寻找）
## 3.同向双指针（滚动窗口）  
### 模板  
```cpp
         j = 1;
        for (int i = 0; i < len; i++){
            j = max(i + 1, j);//通常情况下左指针不能追上右指针。
           while (j < len && i,j的搭配不满足条件) j++;
           if (j >= len) break;
           处理i,j这次搭配；
        }
 ```  
 ### 例1： 全零子串问题 LintCode:1870   
 思路：首先用双指针找到最长的全零子串的左右两端，然后通过左指针在子串内移动的方式计算所有子串的个数，也就是等差1的数量求和
 ```cpp   
     int stringCount(string &str) {
           // Write your code here.
           int len = str.size();
           int j = 1;
           int amount = 0;
           for (int i = 0; i < len; i++){
               if (str[i] != '0') continue;
               j = max(i + 1, j);//通常情况下左指针不能追上右指针。
              while (j < len && str[j] == '0') j++;
              //if (j >= len) break;//这里这句话不需要加，因为最后一个零如果跳过就少一个数了
              amount += j - i;
           }
           return amount;
       }  
```   
### 例2： 找两数差返回target，不能使用额外空间。  
思路： 使用双指针，左指针不动，右指针向右扫描跳过所有差值小于target的情况，下一个要么是相等得到答案要么就不用继续扫描下去，去改变左指针。  
```cpp  
vector<int> twoSum7(vector<int> &nums, int target) {
        target = abs(target);
        int j = 1;
        int len = nums.size();
        for (int i = 0; i < len; i++){
            j = max(i + 1, j);
            while (nums[j] - nums[i] < target && j < len) j++;
            if (j == len) break;//这句话要不要写取决于左指针在最后，右指针在左指针后一个位置这种情况是不是有效的需要考虑的情况。
            if (nums[j] - nums[i] == target) return {nums[i], nums[j]};
        }
        return {-1, -1};
    }  
```  
### 例3： 去除重复元素 LintCode:521    
如果不允许使用额外空间，用双指针做。
```cpp  
int deduplication(vector<int> &nums) {
        if (nums.empty()) return {};
        sort(nums.begin(), nums.end());
        int j = 1;
        int len = nums.size();
        int count = 1;
        for (int i = 0; i < len; i++){
            j = max(i + 1, j);
            while(j < len && nums[j] == nums[i]) j++;
            if (j == len) break;
            nums[i + 1] = nums[j];
            count++;
        }
        return count;
    }  
```  
### 例4：滚动窗口内数求和问题 LintCode:604  
```cpp  
   vector<int> winSum(vector<int> &nums, int k) {
           int j = 0;
           int len = nums.size();
           int sum = 0;
           vector<int> result;
           for (int i = 0; i < len; i++){
               while (j < len && j - i < k){
                   sum += nums[j++];      //在窗口内数没有到k个的时候将数累加起来，当指针停留在第k个元素之后时停下来。
               }
               if (j - i == k) result.push_back(sum);//如果此时窗口内的数准确就记录和，为了排除i在很后面，后面数不够时的情况
               sum -= nums[i]; //窗口大小开够了，就开始向后滚动，需要把第一个数在和中删去。
           }
           return result;
       }
```
