# 拓扑排序是对有向无环图（DAG）的节点进行排序，是在不破坏先后顺序的情况下把DAG拉成一条链。一般使用宽度优先搜索做题。  
排序思路 1.统计所有节点的入度。  
2.将每个入度为0的点放入队列。  
3.去掉放入队列的点以及所有与这些点的连边，相连点的入度减1。  
4.在删除的点的相连点中继续寻找入度为0的点入队重复3操作。    
一个点可能存在多个拓扑序  
## 1.例 课程表（按照课程依赖关系，输出一种课程学习路线） LintCode:616  
思路：根据给出的依赖关系去生成图，然后按照拓扑排序的做法，使用宽度优先搜索决定课程学习顺序放入vector中，如果vector中课程数量与总数不符，就返回空。  
```cpp  
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>> &prerequisites) {
        vector<vector<int>> graph(numCourses);      //这里给出的课程是用0开始的有序编号组成的，所以可以直接用数组存，和哈希表查找复杂度一样。
        vector<int> inDegrees(numCourses,0);        //保存入度的数组
        vector<int> results;                        
        for (int i = 0; i < prerequisites.size(); i++){       //遍历题目给的依赖关系
            auto currPair = prerequisites[i];             
            graph[currPair.second].push_back(currPair.first);    //用题目给的依赖关系生成图
            inDegrees[currPair.first]++;                          //同时统计入度
        }

        queue<int> que;
        for (int i = 0; i < numCourses; i++){                   //先将所有入度为0的点放入队列
            if (inDegrees[i] == 0) que.push(i);
        } 

        while (!que.empty()){
            int curr = que.front();                             
            results.push_back(curr);                             //保存学习课程顺序
            que.pop();
            for (auto nextClass : graph[curr]){                 //取出队列中的点后去图中找到他的后继节点，遍历所有后继节点。
                inDegrees[nextClass]--;                                 //让后继节点的入度都减1
                if (inDegrees[nextClass] == 0) que.push(nextClass);     //后继节点入度减1后若入度为0，就把它们加入队列。
            }
        }
        if (results.size() != numCourses) return {};                      //vector中的课程数量如果等于全部课程数，那就是修完了，否则返回空。
        return results;
    }
};   
```

