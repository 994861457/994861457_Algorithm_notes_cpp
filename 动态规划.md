# 一、记忆化搜索  
使用哈希表记录搜索中的中间结果，从而减少计算。本质上是动态规划。    
---
使用条件：函数需要有返回值，是分治法中的函数，记忆函数的参数是固定的，不变的，相同参数对应相同结果。  
缺点：不适合解决O（n）时间复杂度的问题（递归深度有限制，不然会导致栈溢出）
---
原因：在程序允许运行的时间固定的情况下，O（n）时间复杂度的话，验证程序会去取很大的n进行验证，  
n很大时，由于递归深度也为O（n），导致递归深度很大，造成栈溢出。如果时间复杂度为O(n^2),那么取得n不会特别大。  
总得来说原来时间复杂度越高，在递归深度复杂度相同情况下的，使用空间复杂度换取时间复杂度的性价比越高。
##  例：数字三角形从上到下最短路径 LintCode：109  
可以使用记忆化搜索的原因：数字三角形很像二叉树，但是不同之处在于用分治法递归的时候会有交接部分，不用记忆化搜索就会重复运算。  
O(2^n) -> O(n^2)  
```cpp
  class Solution {
  public:
      int minimumTotal(vector<vector<int>> &triangle) {
           vector<vector<int>> mem(triangle.size(), vector<int>(triangle[triangle.size() - 1].size(),INT_MAX));//自己建哈希表，如果使用map会超时，unorder_map不支持保存pair
                                                                                                               //二维vector的初始化vector<vector<int>> v(m,vector<int>(n,number))
          return divideConquer(triangle, 0, 0,mem);
      }
  private:
      int divideConquer(vector<vector<int>> &triangle,int x,int y, vector<vector<int>> &mem){
          if ( x == triangle.size()) return 0;

          if (mem[x][y] != INT_MAX) return mem[x][y]; //如果遇到已经计算过的情况，则直接从哈希表中调出，不用在向下递归了。
          int left,right;

          left = divideConquer(triangle, x+1, y, mem);
          right = divideConquer(triangle, x+1, y+1, mem); 
          mem[x][y] = triangle[x][y] + min(left, right);  //将结果保存，表示已经计算过了，不用再向下递归计算一次了。
          return mem[x][y];
      }
  };
```  
## 反例  巴什博弈 LintCode:1300  此题就是上述缺陷不能使用的情况，可先用递归得到结果，按照结果找规律得到能被4整除就是失败，其他都成功。  
递归思想：一个人拿石头没有拿光，然后就变成另一个人的先手该问题，他输了就是第一个人赢了，如果这个人也没拿光，又变成第一个人赢了就是赢，需要再取反。  
#  二、动态规划  
大规模问题，依赖于小规模问题的结果 ,求解时需要考虑特殊情况，特殊情况一般出现在方程或者初始化这两项。 
---  
四要素（与递归四要素做对比）：   
1. 状态（递归的定义）：大问题与小问题之间的位置参数关系，例如坐标i，j  
2. 方程（递归的拆解）：大问题如何拆成小问题，大问题与小问题的结果关系    
3. 初始化（递归的出口）：无法再拆解的，最小的问题的值  
4. 答案（递归的调用）： 最终要求得的答案是什么    
5. 方向： 动态规划如果是数组型，循环计算的方向需要考虑状态方程的依赖关系。
两种方法：自顶向下和自底向上  
## 例1：数字三角形最小路径和  LintCode：109    
自顶向下
```cpp  
  int minimumTotal(vector<vector<int>> &triangle) {
    vector<vector<int>> mem(triangle.size(), vector<int>(triangle[triangle.size() - 1].size(),INT_MAX));  
                                                                      //1.状态就是二维数组的坐标
    mem[0][0] = triangle[0][0];                                        //3.初始化
    for (int i = 1; i < triangle.size(); i++){
      mem[i][0] = mem[i - 1][0] + triangle[i][0];        //2.方程 这里方程有两个 其一：边上的节点只依赖于上一个边上的结果
      mem[i][i] = mem[i - 1][i - 1] + triangle[i][i];
     } 

     for (int i = 1; i < triangle.size(); i++){
      for (int j = 1; j < i; j++){
        mem[i][j] = min(mem[i - 1][j - 1], mem[i - 1][j]) + triangle[i][j];   //2.方程  这里方程有两个 其二：内部节点依赖于上一层左右两个节点的结果。
      }
     }
  return *min_element(mem[mem.size() - 1].begin(),mem[mem.size() - 1].end());   //4.答案，到最后一层以后，最小和就是最后一层中的最小值。
  }
```  
自底向上  
```cpp  
   int minimumTotal(vector<vector<int>> &triangle) {
          vector<vector<int>> mem(triangle.size(), vector<int>(triangle[triangle.size() - 1].size(),INT_MAX));  
                                                                                        //1.状态就是二维数组的坐标
          for (int i = 0; i < triangle.size(); i++){
              mem[triangle.size() - 1][i] = triangle[triangle.size() - 1][i];           //3.初始化
          }

          for (int i = triangle.size() - 2; i >= 0; i--){
              for (int j = 0; j <= i; j++){
                  mem[i][j] = min(mem[i + 1][j],mem[i + 1][j + 1]) + triangle[i][j];    //2.方程 这里方程只有一个
              }
          }
          return mem[0][0];                                                             //4.答案
      }  
```  
## 例2：机器人网格走到右下角一共有多少条不同路径 LintCode:114 
自顶向下
```cpp 
  int uniquePaths(int m, int n) {
        vector<vector<int>> mem(m, vector<int>(n));         //1.状态就是二维数组的坐标
        
        for (int i = 0; i < m; i++) mem[i][0] = 1;          //3.初始化
        for (int i = 0; i < n; i++) mem[0][i] = 1;

        for (int i = 1; i < m; i++){
            for (int j = 1; j < n; j++){
                mem[i][j] = mem[i][j - 1] + mem[i - 1][j];  //2.方程
            }
        }
        return mem[m - 1][n - 1];                           //4.答案
    }
```  
自底向上  
```cpp  
  int uniquePaths(int m, int n) {
        vector<vector<int>> mem(m, vector<int>(n));         //1.状态就是二维数组的坐标
        
        for (int i = 0; i < m; i++) mem[i][n - 1] = 1;      //3.初始化
        for (int i = 0; i < n; i++) mem[m - 1][i] = 1;

        for (int i = m - 2; i >= 0; i--){
            for (int j = n - 2; j >= 0; j--){
                mem[i][j] = mem[i][j + 1] + mem[i + 1][j];  //2.方程
            }
        }
        return mem[0][0];                                   //4.答案
    }
```  
# 三、动态规划题的使用场景    
求最值，求可行性，求方案总数（只求方案总数）   如果产生循环依赖关系就不能使用动态规划！！！  
# 四、动态规划的题型分类   
## 1.坐标型 （一维，二维） 
前面两道都是  
### 例1 骑士最短路径二，只能向右边走，求最少步数  
```cpp  
  class Solution {
  public:
      int shortestPath2(vector<vector<bool>> &grid) {
          int n = grid.size();
          int m = grid[0].size();
          vector<int> deltaX = {-1, 1, -2, 2};
          vector<int> deltaY = {-2, -2, -1, -1};
          vector<vector<int>> dp(n,vector<int>(m,INT_MAX));
          dp[0][0] = 0;
          for (int j = 0; j < m; j++){
              for (int i = 0; i < n; i++){
                  if (grid[i][j] == 1) continue;
                  int next = INT_MAX;
                  for (int num = 0; num < 4; num++){        //这里之前写成了n，与前面的n冲突，故循环的名字不能乱取。并且取名字要有一定含义，这样不容易冲突。
                      if ((i + deltaX[num]) < 0 || (i + deltaX[num]) >= n || (j + deltaY[num]) < 0 || (j + deltaY[num]) >= m) continue;
                      next = min(next, dp[i +deltaX[num]][j + deltaY[num]]);
                  }
                  if (next != INT_MAX) dp[i][j] = next + 1;
              }
          }
          if (dp[n - 1][m - 1] == INT_MAX) return -1;
          return dp[n - 1][m - 1];
      }
  };  
```
## 2.前缀型     
前缀型初始化需要最后多一个格子。因为要给第一格考虑空串的问题。这样如果比较数组或字符串时可能下标需要往前挪一格。如下面第一题。
## 3.背包型     
最优，可行性，方案数    


## 4.区间型  
状态是一段区间，求一段区间的最优值，可行性，方案总数。经常是子串，子序列问题。  
状态区间通常是大的区间依赖于更小的子区间  
两种区间循环思路：1.直接循环改变区间的两端 2.循环改变区间的一端以及区间的长度 
```cpp
  int stoneGame(vector<int> &A) {
          if (A.empty()) return 0;
          vector<vector<int> > dp(A.size(),vector<int> (A.size(), INT_MAX));
          for (int i = 0; i < A.size(); i++){
              dp[i][i] = 0;
          }

          for (int length = 2; length <= A.size(); length++){
              for (int i = 0; i <= A.size() - length; i++){
                  int j = i + length - 1;
                  for (int mid = i; mid < j; mid++){
                      dp[i][j] = min(dp[i][mid] + dp[mid + 1][j] + sum(A, i, j), dp[i][j]);
                  }
              }
          }
          return dp[0][A.size() - 1];
      }
```
## 5.状态压缩型（TSP问题）

## 6.匹配型   
主要考虑最后一个字符的匹配关系。
### 1.最长公共子序列  
每次都考虑最后一个字符的匹配，如果最后一个字符相等，那么直接长度加一统计。如果不相等去找去掉其中一个最后的字符的答案（两种情况）选最大值。  
不能忘记空串也要考虑所以要给最前面留一个下标0给空串。
```cpp
  int longestCommonSubsequence(string text1, string text2) {
          vector<vector<int> > dp(text1.size() + 1,vector<int> (text2.size() + 1, 0));
          for (int i = 1; i < text1.size() + 1; i++){
              for (int j = 1; j < text2.size() + 1; j++){
                  if (text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                  else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); 
              }
          }
          return dp[text1.size()][text2.size()];
      }
```  
### 2.最长公共子序列二    
这道题需要输出公共子序列，首先用动态规划来找到子序列的最长长度，然后从最后一格开始搜索长度递减的情况如果遇到所对应字符不相等，就用前面动规的逆向思维，找从dp[i - 1][j] 和dp[i][j - 1]中找，必须往dp值不变的方向移动，不然可能会移动到另外一个长度相等的却后面接不上的子序列。也就是如果遇到字符相等，就往斜对角走（i - 1， j - 1）,如果不相等，则往dp值不变的方向移动。如果不往相等方向移动，那么没遇到相等字符又有dp值的减少，那么说明前面是另外一条。
```cpp
  string LCS(string s1, string s2) {
        int size1 = s1.size();
        int size2 = s2.size();
        vector<vector<int> > dp(size1 + 1, vector<int>(size2 + 1, 0));
        for (int i = 1; i <= size1; i++){
            for (int j = 1; j <= size2; j++){
                if (s1[i - 1] == s2[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else{
                    dp[i][j] = max(dp[i][j - 1],dp[i - 1][j]);
                }
            }
        }
        int maxLen = dp[size1][size2];
        if (maxLen == 0) return "-1";
        int i = size1;
        int j = size2;
        string result = "";
        while (maxLen > 0 ){
            if (s1[i - 1] == s2[j - 1]){
                result += s1[i - 1];
                maxLen--;
                i--;
                j--;
            }
            else{
                if (dp[i - 1][j] == maxLen){
                    i--;
                }
                else j--;
            }
        }
        reverse(result.begin(), result.end());
        return result;
    }
```
## 7.划分型动态规划   
考虑的不是当前指针位置的元素，而是最后一段区间是否有满足的。需要另一个指针j。
### 1.单词划分  
思路，考虑当前指针的最后面一个字符串是否满足条件，若满足，再判断前面，如果也满足就是true。
```cpp  
  unordered_set<string> hashSet;
          int maxLen = 0;
          for (auto word : wordDict){
              hashSet.insert(word);
              if (word.size() > maxLen) maxLen = word.size();
          }

          vector<bool> dp(wordDict.size() + 1, false);
          dp[0] = true;
          for (int i = 1; i < wordDict.size() + 1; i++){
              for (int j = 0; j < i; j++){
                  if (hashSet.count(s.substr(j, i - j))) {
                      dp[i] = dp[j];
                      break;
                  }

              }
          }
          return dp[wordDict.size()];
```
### 2.把数字翻译成字符串   
划分行，将其划分为两位或者一位字符，然后判断满足翻译成字符的条件。
```cpp
int solve(string nums) {
        if (nums.size() == 1 && nums[0] == '0') return 0;  //剔除“0”这种情况
        vector<int> dp(nums.size() + 1);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= nums.size(); i++){
            
            if (nums[i - 2] == '1' || (nums[i - 2] == '2' && nums[i - 1] <= '6')){
                if (nums[i - 1] == '0') dp[i] = dp[i - 2];    //有零的情况比较复杂，单个为0没有字母匹配，所以除掉这种情况
                else dp[i] = dp[i - 2] + dp[i - 1];
            }
            else {
                if (nums[i - 1] == '0') dp[i] = 0;          //同上
                else dp[i] = dp[i - 1];
            }
        }
        return dp[nums.size()];
    }
```
