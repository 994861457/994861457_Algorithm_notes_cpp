# 一、记忆化搜索  
使用哈希表记录搜索中的中间结果，从而减少计算。本质上是动态规划。    
---
使用条件：函数需要有返回值，是分治法中的函数，记忆函数的参数是固定的，不变的，相同参数对应相同结果。  
缺点：不适合解决O（n）时间复杂度的问题（递归深度有限制，不然会导致栈溢出）
---
原因：在程序允许运行的时间固定的情况下，O（n）时间复杂度的话，验证程序会去取很大的n进行验证，  
n很大时，由于递归深度也为O（n），导致递归深度很大，造成栈溢出。如果时间复杂度为O(n^2),那么取得n不会特别大。  
总得来说原来时间复杂度越高，在递归深度复杂度相同情况下的，使用空间复杂度换取时间复杂度的性价比越高。
##  例：数字三角形从上到下最短路径 LintCode：109  
可以使用记忆化搜索的原因：数字三角形很像二叉树，但是不同之处在于用分治法递归的时候会有交接部分，不用记忆化搜索就会重复运算。  
O(2^n) -> O(n^2)  
```cpp
  class Solution {
  public:
      int minimumTotal(vector<vector<int>> &triangle) {
           vector<vector<int>> mem(triangle.size(), vector<int>(triangle[triangle.size() - 1].size(),INT_MAX));//自己建哈希表，如果使用map会超时，unorder_map不支持保存pair
                                                                                                               //二维vector的初始化vector<vector<int>> v(m,vector<int>(n,number))
          return divideConquer(triangle, 0, 0,mem);
      }
  private:
      int divideConquer(vector<vector<int>> &triangle,int x,int y, vector<vector<int>> &mem){
          if ( x == triangle.size()) return 0;

          if (mem[x][y] != INT_MAX) return mem[x][y]; //如果遇到已经计算过的情况，则直接从哈希表中调出，不用在向下递归了。
          int left,right;

          left = divideConquer(triangle, x+1, y, mem);
          right = divideConquer(triangle, x+1, y+1, mem); 
          mem[x][y] = triangle[x][y] + min(left, right);  //将结果保存，表示已经计算过了，不用再向下递归计算一次了。
          return mem[x][y];
      }
  };
```
