# 1.二叉树最近公共祖先  LintCode:474  
两个节点的最近公共祖先，是指两个节点的所有父亲节点中（包括这两个节点），离这两个节点最近的公共的节点。每个节点除了左右儿子指针以外，还包含一个父亲指针parent，指向自己的父亲。  
## 思路：首先把一个节点的所有父节点保存在哈希表中，然后按顺序判断父节点是不是在哈希表里面。
```cpp  
  class Solution {
  public:
      ParentTreeNode * lowestCommonAncestorII(ParentTreeNode * root, ParentTreeNode * A, ParentTreeNode * B) {
           unordered_set<ParentTreeNode * > nodeSet;
           ParentTreeNode * curr = A;
           while (curr){
               nodeSet.insert(curr);
               curr = curr -> parent;
           }
          curr = B;
           while (curr){
               if (nodeSet.find(curr) != nodeSet.end()) return curr;
               curr = curr -> parent;
           }
          return NULL;
      }
  };
```
# 2.两数和 LintCode：1    
```cpp
 vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hash;
        for (int i = 0; i < nums.size(); i++){
            if (hash.find(target - nums[i]) != hash.end()) return {hash[target - nums[i]], i};
            hash.insert(make_pair(nums[i], i));
        }
        return {-1, -1};
    }      
```
# 3. 有效的括号 LeetCode: 20   
单指针，遇到的是左括号就入栈，遇到右括号判断栈顶是不是相对应的左括号，如果不是或者为空，就出错，最终如果栈不是空的说明也是错的
```cpp  
bool isValid(string s) {
        if (s.size() % 2 == 1) return false;
        stack<char> charStack;
        unordered_map<char, char> pairs = {{')','('}, {']','['},{'}','{'}};
        for (auto c : s){
            if (pairs.count(c)){                                                    //相当于find
                if (charStack.empty() || charStack.top() != pairs[c]) return false;
                charStack.pop();
            }
            else {
                charStack.push(c);
            }
        }
        if (charStack.empty()) return true;
        return false;
    }    
```  
# 4. 跳台阶 青蛙一次能跳一个或者两个台阶，问需要跳几次  
```cpp  
  int jumpFloor(int number) {
          if (number == 2) return 2;
          if (number == 1) return 1;
          return jumpFloor(number - 1) + jumpFloor(number - 2);
      }    
```
    
# 5. 判断一个链表是否为回文结构 BM13  
```cpp  
  bool isPail(ListNode* head) {
          ListNode* curr = head;
          stack<int> s;
          int count = 0;
          while (curr) {
              curr = curr -> next;
              count++;
          }
          int count2 = count / 2;
          curr = head;
          for (int i = 0; i < count2; i++){
              s.push(curr -> val);
              curr = curr -> next;
          }

          if (count % 2 == 1) curr = curr -> next;
          while(!s.empty()) {
              if (s.top() != curr -> val) return false;
              s.pop();
              curr = curr -> next;
          }
          return true;
      }  
```
# 6. 判断二叉树是否对称  BM31  
主要判断左右子树是否对称，使用迭代式前序遍历，然后左边用根右左，右边用根左右。判断时空也要入栈，出栈时要比较空的情况，这样比较稳妥。  
```cpp  
  bool isSymmetrical(TreeNode* pRoot) {
          if (!pRoot) return true;
          TreeNode* leftRoot = pRoot -> left;
          TreeNode* rightRoot = pRoot -> right;
          stack<TreeNode*> leftStk;
          stack<TreeNode*> rightStk;
          leftStk.push(leftRoot);
          rightStk.push(rightRoot);
          while (!leftStk.empty() && !rightStk.empty()){
              TreeNode* currLeft = leftStk.top();
              TreeNode* currRight = rightStk.top();
              leftStk.pop();
              rightStk.pop();
              if (!currLeft && !currRight) continue;
              else if (currLeft && currRight) {
                  if (currLeft -> val != currRight -> val) return false;
                  leftStk.push(currLeft -> left);
                  leftStk.push(currLeft -> right);
                  rightStk.push(currRight -> right);
                  rightStk.push(currRight -> left);
              }
              else return false;
          }
          if (leftStk.empty() && rightStk.empty()) return true;
          else return false;
      }  
```
