# 1.二叉树最近公共祖先  LintCode:474  
两个节点的最近公共祖先，是指两个节点的所有父亲节点中（包括这两个节点），离这两个节点最近的公共的节点。每个节点除了左右儿子指针以外，还包含一个父亲指针parent，指向自己的父亲。  
## 思路：首先把一个节点的所有父节点保存在哈希表中，然后按顺序判断父节点是不是在哈希表里面。
```cpp  
  class Solution {
  public:
      ParentTreeNode * lowestCommonAncestorII(ParentTreeNode * root, ParentTreeNode * A, ParentTreeNode * B) {
           unordered_set<ParentTreeNode * > nodeSet;
           ParentTreeNode * curr = A;
           while (curr){
               nodeSet.insert(curr);
               curr = curr -> parent;
           }
          curr = B;
           while (curr){
               if (nodeSet.find(curr) != nodeSet.end()) return curr;
               curr = curr -> parent;
           }
          return NULL;
      }
  };
```
# 2.两数和 LintCode：1    
```cpp
 vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hash;
        for (int i = 0; i < nums.size(); i++){
            if (hash.find(target - nums[i]) != hash.end()) return {hash[target - nums[i]], i};
            hash.insert(make_pair(nums[i], i));
        }
        return {-1, -1};
    }      
```
# 3. 有效的括号 LeetCode: 20   
单指针，遇到的是左括号就入栈，遇到右括号判断栈顶是不是相对应的左括号，如果不是或者为空，就出错，最终如果栈不是空的说明也是错的
```cpp  
bool isValid(string s) {
        if (s.size() % 2 == 1) return false;
        stack<char> charStack;
        unordered_map<char, char> pairs = {{')','('}, {']','['},{'}','{'}};
        for (auto c : s){
            if (pairs.count(c)){                                                    //相当于find
                if (charStack.empty() || charStack.top() != pairs[c]) return false;
                charStack.pop();
            }
            else {
                charStack.push(c);
            }
        }
        if (charStack.empty()) return true;
        return false;
    }    
```  
# 4. 跳台阶 青蛙一次能跳一个或者两个台阶，问需要跳几次  
```cpp  
  int jumpFloor(int number) {
          if (number == 2) return 2;
          if (number == 1) return 1;
          return jumpFloor(number - 1) + jumpFloor(number - 2);
      }    
```
    
