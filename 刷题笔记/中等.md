# 1.最长回文子串 LintCode:200  
选定中心点，通过中心点向两端找最长的回文串，需要考虑到有aba型和abba型两种出发的情况。
```cpp
  class Solution {
public:
    string longestPalindrome(string &s) {
       if (s.empty()) return "";
       string longest ="";
       for (int i = 0; i < s.size(); i++){
        string subString = getPalindrome(s, i, i);
        if (subString.size() > longest.size()) longest = subString;
        subString = getPalindrome(s, i, i + 1);
        if (subString.size() >  longest.size()) longest = subString;  
       }
       return longest;
    }

private:
    string getPalindrome(string &s, int left ,int right){
        while (left >= 0 && right <= s.size() - 1 && s[left] == s[right]){
            left--;
            right++;
        }
        return s.substr(left + 1,right - left - 1);
    }
};
```   
# 2.可以删除一个字符的有效回文串 LintCode：891  
使用while循环找到第一个不同字符的位置，如果找不到说明是回文串，选择性删除一个数，再使用一次这个函数。
```cpp
  class Solution {
public:
    bool validPalindrome(string &s) {
       int left = 0;
       int right = s.size() - 1;
       tuple<int, int> pointPair = findDelete(s, left, right);
       if (get<0>(pointPair) == -1) return true;
       left =  get<0>(pointPair);
       right =  get<1>(pointPair);
       pointPair = findDelete(s, left + 1, right);
       if (get<0>(pointPair) == -1) return true;
       pointPair = findDelete(s, left , right - 1);
       if (get<0>(pointPair) == -1) return true;
       return false;
    }
private:
    tuple<int, int> findDelete(string &s, int left, int right){
        
        while (s[left] == s[right] && left < right){
            left++;
            right--;
        }
        if (left < right) return {left, right};
        return {-1, -1};

    }
};
``` 
# 3.无重复字符的最长子串   LeetCode:3
使用同向双指针， 右指针向右，将经过的元素保存到哈希表中，遇到重复元素停下，然后左指针向左走，在哈希表删除已经离开位置的值，然后指针差打擂台。  
```cpp  
  class Solution {
  public:
      int lengthOfLongestSubstring(string s) {
          int len = s.size();
          int j = 0;
          int maxLen = 0;
          unordered_set<char> hash;
          for (int i = 0; i < len; i++){
              while (j < len && hash.find(s[j]) == hash.end()){
                      hash.insert(s[j++]);
              }
              maxLen = max(maxLen, j - i);
              hash.erase(s[i]);
          }
          return maxLen;
      }
  };  
```  
# 4.替换后的最长重复字符   
同向双指针，需要使用哈希表记录出现最多的字母。右指针遇到出现最多字母的频率+可替换数的情况就停下来将数据打擂台。停下来以后左指针右移，此时需要减掉已经离开的字母，并且需要重新获取最大频率。
  ```CPP
  int characterReplacement(string &s, int k) {
          int len = s.size();
          int maxLen = 0;
          int j = 0;
          int answer = 0;
          unordered_map<char, int> counter;
          for (int i = 0; i < len; i++){ 
              while (j < len && j - i - maxLen <= k ){

                  if (counter.find(s[j]) == counter.end()){
                      counter.insert(make_pair(s[j],0));
                  }
                  counter[s[j]]++;
                  if (counter[s[j]] > maxLen) maxLen = counter[s[j]];
                  j++;
              }
              if (j - i - maxLen > k) answer = max(answer, j - i - 1);
              else answer = max(answer, j - i); 
              counter[s[i]]--;
              int maxLen = 0;
              for (auto c : counter){
                  maxLen = max(maxLen, c.second);
              }
          }
          return answer;
      }
```
