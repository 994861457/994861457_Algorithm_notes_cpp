# 1.可以删除一个字符的有效回文串 LintCode：891  
使用while循环找到第一个不同字符的位置，如果找不到说明是回文串，选择性删除一个数，再使用一次这个函数。
```cpp
  class Solution {
public:
    bool validPalindrome(string &s) {
       int left = 0;
       int right = s.size() - 1;
       tuple<int, int> pointPair = findDelete(s, left, right);
       if (get<0>(pointPair) == -1) return true;
       left =  get<0>(pointPair);
       right =  get<1>(pointPair);
       pointPair = findDelete(s, left + 1, right);
       if (get<0>(pointPair) == -1) return true;
       pointPair = findDelete(s, left , right - 1);
       if (get<0>(pointPair) == -1) return true;
       return false;
    }
private:
    tuple<int, int> findDelete(string &s, int left, int right){
        
        while (s[left] == s[right] && left < right){
            left++;
            right--;
        }
        if (left < right) return {left, right};
        return {-1, -1};

    }
};
``` 
# 2.无重复字符的最长子串   LeetCode:3
使用同向双指针， 右指针向右，将经过的元素保存到哈希表中，遇到重复元素停下，然后左指针向左走，在哈希表删除已经离开位置的值，然后指针差打擂台。  
```cpp  
  class Solution {
  public:
      int lengthOfLongestSubstring(string s) {
          int len = s.size();
          int j = 0;
          int maxLen = 0;
          unordered_set<char> hash;
          for (int i = 0; i < len; i++){
              while (j < len && hash.find(s[j]) == hash.end()){
                      hash.insert(s[j++]);
              }
              maxLen = max(maxLen, j - i);
              hash.erase(s[i]);
          }
          return maxLen;
      }
  };  
```  
# 3.替换后的最长重复字符   
同向双指针，需要使用哈希表记录出现最多的字母。右指针遇到出现最多字母的频率+可替换数的情况就停下来将数据打擂台。停下来以后左指针右移，此时需要减掉已经离开的字母，并且需要重新获取最大频率。
  ```CPP
  int characterReplacement(string &s, int k) {
          int len = s.size();
          int maxLen = 0;
          int j = 0;
          int answer = 0;
          unordered_map<char, int> counter;
          for (int i = 0; i < len; i++){ 
              while (j < len && j - i - maxLen <= k ){

                  if (counter.find(s[j]) == counter.end()){
                      counter.insert(make_pair(s[j],0));
                  }
                  counter[s[j]]++;
                  if (counter[s[j]] > maxLen) maxLen = counter[s[j]];
                  j++;
              }
              if (j - i - maxLen > k) answer = max(answer, j - i - 1);
              else answer = max(answer, j - i); 
              counter[s[i]]--;
              int maxLen = 0;
              for (auto c : counter){
                  maxLen = max(maxLen, c.second);
              }
          }
          return answer;
      }
```   
暴力解法       最坏情况时间复杂度为O（n^2） 
思路：以左指针所在的位置的字符为准，去记录不是该字母出现的次数，也就是要改成该字母的此数，超过了就停下然后打擂台。由于每次右指针都要重新回到左指针处，所以时间复杂度不如上面的解法。
```cpp  
  int characterReplacement(string &s, int k) {

          int len = s.size();

          int maxLen = 0;
          for (int i = 0; i < len; i++){ 
              int j = i ;
              int count = 0;
              while (j < len && count <= k ){
                  if (s[++j] != s[i]) count++;
              }
              if (j - i > maxLen) maxLen = j - i;
          }
          return maxLen;
      }  
```
# 4.最大子数组和 LeetCode：53  
思路很巧妙 把问题看成是分别考虑以每一个元素为节点的子串和的最大值为多少，如果前面的最大子串大于0，那么将前面的串拼接到这个结尾上（数组中的当前元素)。最后的结果不是直接将最后值返回，而是将dp数组中最大值返回，应为所有点为节点的最大值都要考虑一下。  
```cpp  
int maxSubArray(vector<int>& nums) {
       vector<int> dp(nums.size());
       dp[0] = nums[0];
       int maxSub = dp[0];
       for (int i = 1; i < nums.size(); i++){
           if (dp[i - 1] <= 0) dp[i] = nums[i];
           else dp[i] = dp[i - 1] + nums[i];
            maxSub = max(maxSub, dp[i]);
       }
       return maxSub;
    }  
 ```  
 # 5.买卖股票  LeetCode：121  
 实时记录到当前天为止股票的最低价，当价格大于股票最低价时，看看赚的钱是不是比上次判断多，多就更新。  
 ```cpp  
 int maxProfit(vector<int>& prices) {
        int minPrice = INT_MAX;
        int maxProfit = 0;
        for (int i = 0; i < prices.size(); i++){
            if (prices[i] > minPrice) maxProfit = max(maxProfit, prices[i] - minPrice); 
            minPrice = min(minPrice, prices[i]);
        }
        return maxProfit;
    }  
  ```
# 6. 最小的k个数 newke：NC119  
堆排序  
```cpp  
  class Solution {
  public:
      vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
          vector<int> results;
          for (int i = input.size() / 2 - 1; i >= 0 ; i--){
              adjust(input, i, input.size());
          }
          for (int i = 0; i < k; i++){    //k次取出堆顶元素，把末尾元素放到堆顶重新调整。
              results.push_back(input[0]);
              swap(input[0],input[input.size() - 1 - i]);
              adjust(input, 0, input.size() - 1 - i);

          }
          return results;
      }
  private:
      void adjust(vector<int> &input, int index, int len){
          int left =  index * 2 + 1;
          int right = index * 2 + 2;
          int minIndex = index;
          if (left < len && input[left] < input[minIndex]) minIndex = left;
          if (right < len && input[right] < input[minIndex]) minIndex = right;
          if (minIndex != index){
              swap(input[minIndex], input[index]);
              adjust(input, minIndex, len);
          }
      }
  };  
```  
快排  
```cpp  
  class Solution {
  public:
      vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
          quickSort(input, 0, input.size() - 1, k);
          return vector<int> (input.begin(),input.begin() + k);
      }
  private:
      void quickSort(vector<int> &input, int start, int end, int k){
          while (start >= end) return;
          int left = start;
          int right = end;
          int pivot = input[start + (end - start) / 2];
          while (left <= right){
              while (left <= right && input[left] < pivot) left++;
              while (left <= right && input[right] > pivot) right--;
              if (left <= right){
                  swap(input[left], input[right]);
                  left++;
                  right--;
              }
          }
          if (start < k) quickSort(input, start, right, k); //如果左侧区间在k以内就需要排序了，说明区间不是完全无关前k个位置
          if (left < k) quickSort(input, left, end, k);
      }
  };  
```
# 7.大数加法 newke:NC1  
倒着排短的补零这样方便，然后再倒回来
```cpp  
  string solve(string s, string t) {
          reverse(s.begin(), s.end());
          reverse(t.begin(), t.end());
          int tSize = t.size();   //多次遇到的问题 .size()在插入过程中会动态变化，所以要在开始先保存。
          int sSize = s.size();
          if (tSize < sSize){
              for (int i = 0; i < sSize- tSize; i++){
                  t.push_back('0');
              }
          }
          else{
              for (int i = 0; i < tSize - sSize; i++){
                  s.push_back('0');
              }
          }
          int carry = 0;
          string result;
          for (int i = 0; i < t.size(); i++){
              int sum = s[i] - '0' + t[i] - '0' + carry;
              carry = sum / 10;
              if (sum != 10){
                  int x = 0;
              }
              result.push_back('0' + (sum % 10));
          }
          if (carry == 1) result.push_back('1');
          reverse(result.begin(), result.end());
          return result;
      }
```
