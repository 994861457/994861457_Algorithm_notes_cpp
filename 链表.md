# 链表 
1.做链表的题一定要用纸笔写下来  
2.对于新建链表的题，需要创建一个虚拟节点dummyNode这样以后的while循环可以直接开始，而不用单独出来写第一个节点的情况。
## 1.单向链表的创建与打印  
```cpp  
 struct ListNode {
   int val;
   ListNode *next;
   ListNode() : val(0), next(nullptr) {}
   ListNode(int x) : val(x), next(nullptr) {}
   ListNode(int x, ListNode *next) : val(x), next(next) {}
 };

 ListNode* createLinkedList(vector<int> list) {
   ListNode* dummy = new ListNode(0);
   ListNode* pre = dummy;
   for (auto num : list) {
     ListNode* newNode = new ListNode(num);
     pre -> next = newNode;
     pre = newNode;
    }
    pre -> next = nullptr;
    return dummy -> next;
 }

 void printLinkedList(ListNode* head) {
    while (head) {
      cout << head -> val << ' ';
      head = head -> next;
  }
 }
```
## 2.反转链表 LeetCode:206  
思路： 迭代，使用双指针法，一个指针用于保存前一个节点是什么，一个指针指向当前节点。
用临时变量暂存当前指针的下一个节点的地址，然后改变当前指针指向的下个节点为原来的前一个节点pre，然后更新pre为当前节点，更新curr为下一个节点（保存于临时变量）。  
```cpp  
 ListNode* reverseList(ListNode* head) {
        ListNode* curr = head;
        ListNode* pre = nullptr;
        while(curr != nullptr){
            ListNode* temp = curr -> next;
            curr -> next = pre;
            pre = curr;
            curr = temp;
        }
        return pre;            
    }
```   
## 3.k个一组反转链表 LeetCode:25    
![](https://github.com/994861457/994861457_Algorithm_notes_cpp/blob/main/%E5%9B%BE%E7%89%87/QQ%E5%9B%BE%E7%89%8720220218205401.jpg)   
思路： 这道题的核心思路是四个指针 pre start end next，每一轮循环的开始，pre在需要翻转的部分的前面一个节点，start在翻转部分的第一个节点，end和next在start的位置。  
然后先移动end并遍历看看节点数够不够，不够就直接返回，够了end就会停在待翻转部分最后，next在end后面一个节点。使用curr与prep指针做局部翻转，prep初始就是next，这样next一边就和翻转后的部分接上了，然后是pre，pre->next = end 就把pre一边接好了，然后就是pre变为start（现在start才是next之前的一个节点） ，start变为next所在位置，end再回到start等待检查翻转部分长度够不够。
```cpp  
class Solution {
public:
	ListNode* reverseKGroup(ListNode* head, int k) {
		ListNode* dummy = new ListNode(0, head);
		ListNode* pre = dummy;
		ListNode* start = head;
		ListNode* end = start;
		ListNode* next = start;
		while (next) {
			for (int i = 0; i < k - 1; i++) {
				end = end->next;
				if (!end) return dummy->next;
			}
			next = end->next;
			ListNode* curr = start;
			ListNode* prep = next;
			while (curr != next) {       //易错点1 next写成 end -> next,这里end所指向的节点的next是会变的
				ListNode* temp = curr->next;
				curr->next = prep;
				prep = curr;
				curr = temp;
			}
			pre -> next = end;	//易错点2 不要接反了
			pre = start;		//易错点3 现在next前的节点已经不是end了而是pre指向的节点
			start = next;
			end = start;
		}
		return dummy->next;
	}
};
```  
## 4.合并有序链表  LeetCode：21  
```cpp  
	class Solution {
	public:
	    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
		ListNode* dummy = new ListNode(0);
		ListNode* curr = dummy;
		while (list1 && list2){
		    if (list1 -> val <= list2 -> val){
			curr -> next = list1;
			list1 = list1 -> next;
		    }
		    else{
			curr -> next = list2;
			list2 = list2 -> next;
		    }
		    curr = curr -> next;
		}
		if (!list1) curr -> next = list2;
		if (!list2) curr -> next = list1;
		return dummy -> next;
	    }
	};  
```
## 5.链表有无环问题  LeetCode：141  
方法1  使用哈希表记录走过的节点，遇到访问过的节点就表示有环。
```cpp  
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_set<ListNode *> hash;
        while (head){
            if (hash.find(head) != hash.end()) return true;
            hash.insert(head);
            head = head -> next;
        }
        return false;
    }
};  
```  
方法2 使用快慢指针，一个指针一次跳一格，一个两格，如果两个指针相遇，则有环，如果遇到空退出循环就表示没有环。  
## 6. 相交链表  
方法一： 使用两个哈希表，互相查看有无访问过  
方法二： 首先让两个点以相同速度走，短链表到头后记录长链指针的位置，就能求出长短差距。在第二次出发时把差距补齐一起走，不断判断是否相等，第一个相等点就是交叉口，如果一直不相等就是不相交
